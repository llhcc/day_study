<2014-6-20></2014-6-20>
一、Sql与hql区别：
Hql都是对象，
        StringBuffer sql = new StringBuffer();
		sql.append("from LicSelfTask t where t.taskEndTime < to_date('"+DateUtils.getSimpleFormatDate(new Date())+"','yyyy-MM-dd')");
		sql.append(" and (t.taskState != '3' or t.taskState is null)");
		sql.append(" and t.attr is null");
hql封装为Map：
StringBuffer queryString = new StringBuffer("");
queryString
		.append(" select new map (cm.legalname as legalname,cm.linkman as linkman,cm.linkmanphone as linkmanphone,cm.linkmanmobile as linkmanmobile,al.workflowname as workflowname,e.accepttime as accepttime,e.users2 as users2,vl.siteauditleader as siteauditleader,vl.siteauditmember as siteauditmember,vl.siteaudittime as siteaudittime,cm.linkmanemail as linkmanemail,cm.remark as remark,cm.address as address,vl.enterexpandid as enterexpandid,al.tablename as tablename,cm.province as province )");
queryString.append(" from VLicSiteauditAll vl, CmEnterprise cm, VLicAllTracesZz e, VLicAllEnterprise al");
queryString
		.append(" where vl. enterid = cm.enterid and vl.enterarchiveid = e.enterarchiveid and vl.enterid = al.enterid and al.enterarchiveid=e.enterarchiveid and cm.entertype =4");
if (StringUtils.isNotBlank(endDate)) {
	queryString.append(" and to_char(vl.siteaudittime,'yyyy-MM-dd') <= '" + endDate + "'");
}
if (StringUtils.isNotBlank(starDate)) {
	queryString.append(" and to_char(vl.siteaudittime,'yyyy-MM-dd') >= '" + starDate + "'");
}
queryString.append(" order by vl.siteaudittime desc");

sql语句:
sql.append("select * from lic_self_task_detail t left join cm_enterprise c on (t.enter_id=c.enterid) left join lic_self_enterprise e on (t.enter_id=e.enterid) where t.task_id='"+map.get("taskId").toString()+"'");

sql赋值：
String sql = "select count(e.taskenter_id) from lic_self_task_detail e where e.task_id ='"+taskId+"' and e.entertype =:entertype and e.conclusion=:conclusion";
          Map<String, Object> yxEvaluateMap = new HashMap<String, Object>();
          yxEvaluateMap.put("entertype", enter);
		  yxEvaluateMap.put("conclusion", "1");

public List executeListSQL(final String sql,
			final Map<String, Object> params) {
		return (List) this.hibernateTemplate.execute(new HibernateCallback() {
			public Object doInHibernate(Session session)
					throws HibernateException {
				SQLQuery query = session.createSQLQuery(sql);
				if (params != null && params.size() > 0) {
					for (String key : params.keySet()) {
						query.setParameter(key, params.get(key));
					}
				}
				return query.list();
			}
		});
	}

public List executeListReturnMap(final String sql,
			final Map<String, Object> params) {
		return (List) this.hibernateTemplate.execute(new HibernateCallback() {
			public Object doInHibernate(Session session)
					throws HibernateException {
				SQLQuery query = session.createSQLQuery(sql);
				if (params != null && params.size() > 0) {
					for (String key : params.keySet()) {
						query.setParameter(key, params.get(key));
					}
				}			
				query.setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP);
				return query.list();
			}
		});
	}

Map值页面赋值：
<td>
	<c:if test="${fn:contains(info.ENTERTYPE,',') eq true}">
		 <c:forEach items="${fn:split(info.ENTERTYPE,',')}" var="e">
		   <bsi:showDict businessType="f0b7d3d7-d603-4a5f-b48d-5bb8cf4da1a2" itemValue="${e}"/>
		 </c:forEach>
	 </c:if>
	 <c:if test="${fn:contains(info.ENTERTYPE,',') eq false}">
		   <bsi:showDict businessType="f0b7d3d7-d603-4a5f-b48d-5bb8cf4da1a2" itemValue="${info.ENTERTYPE}"/>
	 </c:if>
</td>

sql语句查询是否不等于某个值
String hql = "from LicSelfTaskDetail s where (s.fillStatus != 4 or s.fillStatus is null) and s.taskId ='"+licSelfTaskDetail.getTaskId()+"'";


二、附件保存
<form action="<%=basePath%>selfTask/selfTaskSave.action?taskId=${licSelfTask.taskId}" method="post" id="savelink" enctype="multipart/form-data">
</form>

三、js用法
$("input[name='licSelfTaskDetail.conclusion']").eq(0).attr("checked","checked");
$("input[name='licSelfTaskDetail.conclusion']").eq(1).removeAttr("checked");
var att16=document.getElementById("licSelfEnterprise.att5").value;
$("#sa").bind("submit", function(){
	var action = $(this).attr("action");
	var param = $(this).serialize();
	ajax(action, param, "", "success", "");
});
function ajax(ajaxurl, param, beforeMethod, successMethod,errorMethod)
{
	if(ajaxurl == null || $.trim(ajaxurl) == "")
	{
		jAlert("ajax请求地址不能为空","温馨提示");
		return;
	}
	if(successMethod == null || $.trim(successMethod) == "")
	{
		jAlert("必须指定请求成功后执行的方法","温馨提示");
		return;
	}
	$.ajax({
		   type: "POST",
		   url: ajaxurl,
		   data: param,
		   beforeSend: eval(beforeMethod),
		   error: eval(errorMethod),
		   success: eval(successMethod)
	});
}
四、jsp页面用法
<td width="15%">
<select name="conclusion" id="conclusion">
   <option value="">==请选择==</option>
   <option value="1" <c:if test="${'1' == conclusion }">selected</c:if>>表现优秀</option>
	<option value="2" <c:if test="${'2' == conclusion }">selected</c:if>>符合要求</option>
	<option value="3" <c:if test="${'3' == conclusion }">selected</c:if>>建议整改</option>
</select>
</td>
<fmt:formatDate value="${info.taskBeginTime}" pattern="yyyy-MM-dd"/>

五、prepare用法
方法执行顺序： prepareMethodName --> prepare -->validateMethodName --> MethodName

public void prepareSelfTaskSave(){
	String taskId = request.getParameter("taskId");
	if(StringUtils.isNotBlank(taskId)){
		licSelfTask = licSelfTaskService.get(LicSelfTask.class, taskId);
	}
}
public String selfTaskSave(){
	licSelfTask.setTaskState("3");
	licSelfTaskService.saveOrUpdate(licSelfTask);
	return null;
}
前提条件：
public class BaseAction extends ActionSupport implements Preparable ,ServletRequestAware, ServletResponseAware, Serializable{
public void prepare() throws Exception 
{
	String method = ServletActionContext.getRequest().getMethod();
	isPost = method.equalsIgnoreCase("POST");
	isGet = method.equalsIgnoreCase("GET");
	contextPath = ServletActionContext.getRequest().getContextPath();
	request = ServletActionContext.getRequest();
	response = ServletActionContext.getResponse();
	session = request.getSession();
	user = (CmUser)session.getAttribute(UploadConstant.SESSION_USERNAME);
	ActionContext context = ActionContext.getContext();
	Map queryMap = context.getParameters();
	if(null == queryParameter){
		queryParameter = new QueryParameter();
		Set<String> key = queryMap.keySet();
		for (Iterator it = key.iterator(); it.hasNext();) {
			String nowKey = (String) it.next();
			String[] tempStr = (String[]) queryMap.get(nowKey);
			if(null != tempStr && tempStr.length > 0){	            	
				queryParameter.addParameter(nowKey, tempStr[0]);
			}
		}
		
	}
}
@Override
public void setServletResponse(HttpServletResponse response) {
	this.response = response;		
}

@Override
public void setServletRequest(HttpServletRequest request) {
	this.request = request;		
}
}

六、java类使用
//输出流,可用于AJAX返回，文件下载等
protected InputStream inputStream;
public InputStream getInputStream() {
		return inputStream;
	}
public void setInputStream(InputStream inputStream) {
		this.inputStream = inputStream;
	}
Map session = ServletActionContext.getContext().getSession();
CmUser cmUser = (CmUser)session.get(UploadConstant.SESSION_USERNAME);

@Component
public class SpringUtil implements ApplicationContextAware {
    private static ApplicationContext applicationContext;
    public void setApplicationContext(ApplicationContext arg0)
        throws BeansException {
        SpringUtil.applicationContext = arg0;
    }
    public static Object getBean(String name){
        return applicationContext.getBean(name);
    }
    public ApplicationContext getApplicationContext()
    {
    	return applicationContext;
    }
}

public void addFileToStream(String filename)
{
	try {
		ServletActionContext.getResponse().setHeader("Content-Disposition",
				"attachment;filename=" + new String(filename.getBytes(),"iso-8859-1"));
	} catch (UnsupportedEncodingException e) {
		e.printStackTrace();
	}	
}
七、文件下载
<td class="tdtext" width="30%" title="法人声明文件（盖公章）">
	<font color="red">*</font>法人声明文件（盖公章）
	<br/><br/>
	<a style="color:blue;" href="${context_path}/attachment/legalperson.doc" title="加盖公章，再扫描并将扫描件上传">点击：下载法定代表人声明模板</a>
</td>
attachment为文件目录，legalperson为文件名

八、文件下载保存





九、java文件操作
// 复制文件
public static void copyFileToFile(String src, String dest) throws Exception {
	if (org.apache.commons.lang3.StringUtils.isBlank(src) || org.apache.commons.lang3.StringUtils.isBlank(dest)) {
		return;
	}
	File srcFile = new File(src);
	File destFile = new File(dest);
	if (!destFile.exists()) {
		FileUtils.touch(destFile);
	}
	FileUtils.copyFile(srcFile, destFile);
}
// 创建目录及文件
public static void createFile(String filePath) throws Exception {
	String directory = filePath.substring(0, filePath.lastIndexOf(File.separator));
	File file = new File(directory);
	if (!file.exists()) {
		file.mkdirs();
	}
	file = new File(filePath);
	if (!file.exists()) {
		file.createNewFile();
	}
}
// 删除目录及目录下的文件
public static void deleteAll(File file) {
	if (file.isFile() || file.list().length == 0) {
		file.delete();
	} else {
		File[] files = file.listFiles();
		for (int i = 0; i < files.length; i++) {
			deleteAll(files[i]);
			files[i].delete();
		}
		if (file.exists()) // 如果文件本身就是目录 ，就要删除目录
			file.delete();
	}
}
// 自动根据系统类型，来替换文件路径的分隔符
public static String replaceFileseparator(String filePath) {
	// windows
	if (File.separator.equals("\\")) {
		filePath = filePath.replaceAll("/", "\\\\");
	} else if (File.separator.equals("/")) {// UNIX 系统
		filePath = filePath.replaceAll("\\\\", "/");
	}
	return filePath;
}
//取得文档的绝对路径
public static String getWebContentPath2() {
	String str = FileUtil.class.getResource("/").toString();
	if (File.separator.equals("\\")) {
		return str.substring(6, str.length() - 16);
	}
	return str.substring(5, str.length() - 16);
}

十、生成Excel
public static void siteAduitExelExport(String siteAduitFile, List<Object> list) throws FileNotFoundException, IOException{
		ILicApplyEnterpriseService applyenterpriseService = (ILicApplyEnterpriseService)SpringUtil.getBean("applyenterpriseService");;
		HSSFWorkbook workbook = new HSSFWorkbook(new FileInputStream(siteAduitFile));
		HSSFCellStyle cellStyle=workbook.createCellStyle(); 
		cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);
		cellStyle.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);
		cellStyle.setWrapText(true);
		HSSFSheet sheet0 = workbook.getSheetAt(0);
		sheet0.addMergedRegion(new CellRangeAddress(1,1,0,11));
		HSSFRow row = sheet0.getRow((short)(1));
		HSSFCellStyle style=workbook.createCellStyle(); 
		style.setAlignment(HSSFCellStyle.ALIGN_LEFT);
		row.getCell(0).setCellStyle(style);
		row.getCell(0).setCellValue("编号："+new SimpleDateFormat("yyyy-MM-dd").format(new Date()));
		
		if(list!=null){
			for(int m = 0; m < list.size(); m++){
				
				row = sheet0.getRow((short)(m+3));
				if(null == row){
					row = sheet0.createRow((short)(m+3));
				}
				for(int i = 0; i < 13; i++){
                    row.createCell(i).setCellStyle(cellStyle);
                }
				Object objList = list.get(m);
				Map map = (Map)objList;
				row.getCell(0).setCellValue(m+1);
				row.getCell(1).setCellValue(com.bsi.util.StringUtils.null2Empty(map.get("legalname")));
				row.getCell(2).setCellValue((map.get("linkman")!=null?map.get("linkman").toString()+new HSSFRichTextString("\r\n"):"")+(map.get("linkmanphone")!=null?map.get("linkmanphone").toString()+new HSSFRichTextString("\r\n"):"")+(map.get("linkmanmobile")!=null?map.get("linkmanmobile").toString():""));
				
				String workFlowCn = WorkFlowUtils.findWorkFlowCnByWorkFlow(map.get("workflowname")!=null?map.get("workflowname").toString():"");
				String tableName = com.bsi.util.StringUtils.null2Empty(map.get("tablename"));
				String enterexpandid = com.bsi.util.StringUtils.null2Empty(map.get("enterexpandid"));
				String czxGrand = "";
				if("lic_apply_enterprise".equalsIgnoreCase(tableName)){
					LicApplyzzExpand licApplyzzExpand = applyenterpriseService.get(LicApplyzzExpand.class, enterexpandid);
				    czxGrand = EnterpriseSupport.convertLicencetype(licApplyzzExpand.getLicencetype(),licApplyzzExpand.getCzgrade(),licApplyzzExpand.getCxgrade(),licApplyzzExpand.getCsgrade());
				}else if("lic_change_enterprise".equalsIgnoreCase(tableName)){
					LicChangezzExpand licChangezzExpand = applyenterpriseService.get(LicChangezzExpand.class, enterexpandid);
					czxGrand = EnterpriseSupport.convertLicencetype(licChangezzExpand.getLicencetype(),licChangezzExpand.getCzgrade(),licChangezzExpand.getCxgrade(),licChangezzExpand.getCsgrade());
				}
				row.getCell(3).setCellValue(workFlowCn+":"+czxGrand.trim());
				SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
				try {
					row.getCell(4).setCellValue(map.get("accepttime")!=null?format.format(format.parse(map.get("accepttime").toString())):"");
				} catch (ParseException e) {
					e.printStackTrace();
				}
				row.getCell(5).setCellValue(com.bsi.util.StringUtils.null2Empty(map.get("users2")));
				row.getCell(6).setCellValue(com.bsi.util.StringUtils.null2Empty(map.get("siteauditleader")));
				row.getCell(7).setCellValue(com.bsi.util.StringUtils.null2Empty(map.get("siteauditmember")));
				try {
					row.getCell(8).setCellValue(map.get("siteaudittime")!=null?format.format(format.parse(map.get("siteaudittime").toString())):"");
				} catch (ParseException e) {
					e.printStackTrace();
				}
				row.getCell(9).setCellValue(com.bsi.util.StringUtils.null2Empty(map.get("linkmanemail")));
				row.getCell(10).setCellValue(com.bsi.util.StringUtils.null2Empty(map.get("remark")));
				row.getCell(11).setCellValue(com.bsi.util.StringUtils.null2Empty(map.get("address")));
				Map session = ServletActionContext.getContext().getSession();
				List<CmArea> areaList = (ArrayList<CmArea>)session.get(UploadConstant.SESSION_AREA);
				StringBuffer sf = new StringBuffer();
				if(areaList != null && areaList.size() > 0)
		        {
		            for(CmArea item : areaList)
		            {
		                if(item.getAreacode().equals(map.get("province")))
		                {
		                	sf.append(item.getAreaname());
		                    break;
		                }
		            }
		        }
				row.getCell(12).setCellValue(com.bsi.util.StringUtils.null2Empty(sf.toString()));
			}
		}
		try {
            FileOutputStream fileOut = new FileOutputStream(siteAduitFile);
            workbook.write(fileOut);
            fileOut.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
	}

Action代码：
File file = new File(filename);
setInputStream(FileUtils.openInputStream(file));
response.addHeader("Content-Disposition", "attachment;filename=" + java.net.URLEncoder.encode("现场核查计划安排表.xls", "UTF-8"));
response.setContentType("text/html");
return "input";

xml代码：
<result name="input" type="stream">
	<param name="inputName">inputStream</param>
	<param name="contentType">${ contentType };charset=utf-8</param>
</result>

十一、Tag标签创建
<?xml version="1.0" encoding="UTF-8"?>
<taglib xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"
	version="2.0">
	<tlib-version>2.2.3</tlib-version>
	<jsp-version>1.2</jsp-version>
	<short-name>bsi</short-name>
	<uri>http://www.51bsi.com</uri>
	<display-name>http://www.51bsi.com</display-name>
    
	<function>
		<name>isEmpty</name>
		<function-class>com.bsi.tag.Functions</function-class>
		<function-signature>boolean isEmpty(java.lang.Object)</function-signature>
	</function>

	<tag>
		<name>getValForMap</name>
		<tag-class>com.bsi.tag.GetValForMapTag</tag-class>
		<body-content>empty</body-content>
		<description>实现key到map获取类型</description>
		<attribute>
			<name>key</name>
			<required>true</required>
			<rtexprvalue>true</rtexprvalue>
			<description>key值</description>
		</attribute>
		<attribute>
			<name>map</name>
			<required>true</required>
			<rtexprvalue>true</rtexprvalue>
			<description>map申请类型</description>
		</attribute>
	</tag>
</taglib>

public class GetValForMapTag extends SimpleTagSupport {
	private String key;
	private Map<String, Object> map;
	@Override
	public void doTag() throws JspException, IOException {
		Writer out = getJspContext().getOut();
		if(StringUtils.isNotBlank(key) && map != null){
			if(map.get(key)==null){
				out.write("");
				out.flush();
			}else{
				out.write(map.get(key).toString());
				out.flush();
			}
		}
	}
}
public class Functions extends SimpleTagSupport {
	public static boolean isEmpty(Object object) {
		if (object == null) {
			return true;
		}
		if (object instanceof String) {
			String str = (String) object;
			return StringUtils.isEmpty(str);
		} else if (object instanceof List) {
			List list = (List) object;
			return ListUtils.isEmpty(list);
		}
		return false;
	}
}
jsp页面：<%@ taglib uri="/WEB-INF/tld/bsi.tld" prefix="bsi" %>
<bsi:getValForMap key="${}" map="${}"/>


十二、webservices使用
<?xml version="1.0" encoding="UTF-8"?>
<beans
	xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:jaxws="http://cxf.apache.org/jaxws"  
	xsi:schemaLocation=
	"http://www.springframework.org/schema/beans 
	 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
	 http://cxf.apache.org/jaxws 
	 http://cxf.apache.org/schemas/jaxws.xsd">
	<import resource="classpath:META-INF/cxf/cxf.xml" />    
    <import resource="classpath:META-INF/cxf/cxf-extension-soap.xml" />    
    <import resource="classpath:META-INF/cxf/cxf-servlet.xml" />    
    <bean id="hello" class="com.bsi.service.impl.HelloWordServImpl" />    
    <jaxws:endpoint id="helloWorld" implementor="#hello"    
        address="/helloWorld" /> 
    <jaxws:endpoint id="qualificationWebService" implementor="com.bsi.ws.Impl.QualificaionWebServiceImpl" address="/qualificationWebService" />
    <jaxws:client id="systemWebService" address="http://192.168.7.209:8080/OVI_Framework/service/systemWebServiceXK?wsdl" serviceClass="com.bsi.ws.SystemWebService" />     
</beans>

web.xml
<!-- 配置webservices -->
	<servlet>
		<servlet-name>CXFServlet</servlet-name>
		<servlet-class>
			org.apache.cxf.transport.servlet.CXFServlet
		</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>CXFServlet</servlet-name>
		<url-pattern>/ws/*</url-pattern>
	</servlet-mapping>

/**
 * JAX-WS2.0的WebService接口定义类.
 * 
 * 使用JAX-WS2.0 annotation设置WSDL中的定义.
 * 使用WSResult及其子类类包裹返回结果.
 * 使用DTO传输对象隔绝系统内部领域对象的修改对外系统的影响.
 * 
 * @author xxx
 */
@WebService
public interface SystemWebService {
	public List<SysUserDTO> getBureauLeaderList(); 
	public SysUserDTO getPrmUserByUser(@WebParam(name = "id") Long id);
	public String sayHello(@WebParam(name = "text") String text); 
	public List<SysUserDTO> getUserInfo();
	public List<SysDeptDTO> getUserDeptInfo();
	public SysUserDTO getUserByLoginIdAndPwd(@WebParam(name = "login") String login, @WebParam(name = "pwd")String pwd);
	public SysUserDTO getUserById(@WebParam(name = "id") Long id);
	/**
	 * 
	 * @Des 根据登录id获取用户
	 * @Step
	 * @Version <1> xxx 2013-4-22
	 * @param loginId
	 * @return
	 */
	public SysUserDTO getUserByLoginId(@WebParam(name = "loginId") String loginId);
	public List<SysUserSubDTO> getUserStatus(@WebParam(name = "effective")String statusTime);
	public SysUserSubDTO getUserStatusByLoginId(@WebParam(name = "effective")String statusTime, @WebParam(name = "login") String login);
	public List<SysUserDTO> getUserbySuperUser(@WebParam(name = "id") Long id);
	/**
	 * 
	 * @title getMenuList
	 * @Description: 根据用户id获取所属资源列表
	 * @author xxx
	 * @param id 用户id
	 * @return 资源列表
	 */
	public List<SysResourceDTO> getMenuList(@WebParam(name = "id") Long id);
	public boolean changePwd(@WebParam(name = "sysUser") SysUserDTO sysUser);
    public SysDeptDTO getUnit(@WebParam(name = "id") Long id);
}

http://192.168.7.209:8080/OVI_Framework:
<!-- webService 配置 -->	
	<jaxws:endpoint id="systemWebServiceXK" implementor="com.bsi.webservice.impl.SystemWebServiceXKImpl" address="/systemWebServiceXK" />

localhost:
访问路径：http://localhost:8088/SCSERC_Qualification/ws/qualificationWebService?wsdl

/**
 * WebService常量定义.
 */
public class WsConstants {
	/**项目内统一的NameSpace定义.**/
	public static final String NS = "http://nf.system.scserc.com";
}

//name 指明wsdl中<wsdl:portType>元素的名称
@WebService(name = "qualificationWebService", targetNamespace = WsConstants.NS)
public interface QualificationWebService {
}

@WebService(serviceName = "qualificationWebService", endpointInterface = "com.bsi.ws.QualificationWebService", targetNamespace = WsConstants.NS)
public class QualificaionWebServiceImpl implements QualificationWebService {
}

十三、数据库导入导出
远程cmd命令：mstsc
数据库导入：
my objects ---> 删除文件：procedures，tables，views，sequences

imp scserc/scserc@INNER file=d:\bsi\nei_0609.dmp full=y

用户名：就是你的目标用户 。
密码：就是你的目标用户登录密码。
orcl:是实例名称 就是数据库名。
file：就是你要导入的dmp文件全路径。
full=y 是否全部导入只有当前用户是dba的时候才能用此选项 。

将数据库TEST完全导出,用户名system 密码manager 导出到D:\daochu.dmp中

exp system/manager@TEST file=d:\daochu.dmp full=y


<2014-6-21></2014-6-21>

<2014-6-23>
一、js用法
$("#addfile").click(function(){
	count++;
	var br = $("<br>");
	var input1 = $("<input  id='inputrecievedocument_"+count+"' class='shuru1' type='text' style='width:80%'/>");
	var input2 = $("<input type='button' class='btn_new'  id='btnrecievedocument' value='浏览'/>");
	var input3 = $("<input name='upfile' type='file' style='position:absolute;filter:alpha(opacity=0);width:40px;margin-bottom:5px;' id='t_file' onchange='inputrecievedocument_"+count+".value=this.value' hidefocus/>");
	var button = $("<input type='button' value='删除' class='btn_new'>");
	$("#attachfile").append(input1).append(input3).append(input2).append(button).append(br);
	$("#fileLabel span").css('margin-top',$('#fileContent').height()/2-13.5+'px');
	button.click(function() {
		br.remove();
		input1.remove();
		input2.remove();
		input3.remove();
		button.remove();
		$("#fileLabel span").css('margin-top',$('#fileContent').height()/2-13.5+'px');
	});
});

二、jsp页面（IE强制刷新）
<%
    request.setAttribute("decorator", "none");
    response.setHeader("Cache-Control","no-cache"); //HTTP 1.1 设置控件不使用cache
    response.setHeader("Pragma","no-cache"); //HTTP 1.0  设置不使用cache
    response.setDateHeader ("Expires", 0); //prevents caching at the proxy server 设置cache过期时间为0
%>
</2014-6-23>

<2014-6-25>
一、jsp页面
<c:set var="context_path" value="${pageContext.request.contextPath}" />
<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
String httpPath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort() + "/";
%>

<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%>
<c:when test="${fn:length(showWaitLst) gt 0}">
</c:when>

二、js用法
var attr = document.getElementById("licSelfTask.attr").value;
var attr = $("#licSelfTask.attr").val();

var attr = '${#licSelfTask.attr}';
var a = $("form table").eq(2).children('tbody').children('tr').children('td').children('input');
var a = $("form table").eq(2).find('input');
alert(a.html());

var actionname=$("#savelink").attr("action");
var paramname = $("#savelink").serialize();
ajax(actionname,paramname, "", "successCallback", "");

function ajax(ajaxurl, param, beforeMethod, successMethod,errorMethod)
{
	if(ajaxurl == null || $.trim(ajaxurl) == "")
	{
		jAlert("ajax请求地址不能为空","温馨提示");
		return;
	}
	if(successMethod == null || $.trim(successMethod) == "")
	{
		jAlert("必须指定请求成功后执行的方法","温馨提示");
		return;
	}
	$.ajax({
		   type: "POST",
		   url: ajaxurl,
		   data: param,
		   beforeSend: eval(beforeMethod),
		   error: eval(errorMethod),
		   success: eval(successMethod)
	});
}
加红
$(document).ready(function(){
	$('.required').each(function(){
		if ($(this)[0].tagName.toLowerCase() == 'textarea' || $(this).attr('type') == 'radio' || $(this).attr('type') == 'checkbox') {
			if ($(this).parent().parent().prev().has('.red').length == 0) {
				$(this).parent().parent().prev().html('<font class="red">*</font>' + $(this).parent().parent().prev().html());
			}
		} else {
			$(this).parent().prev().html('<font class="red">*</font>' + $(this).parent().prev().html());
		}
	});
});

</2014-6-25>
<2014-6-26>

</2014-6-26>

<2014-6-30>

</2014-6-30>
<2014-7-2>
一、存储过程：
create or replace procedure 存储过程名称 as
begin
存储过程定义
end 存储过程名称

二、hibernate缓存机制
一级缓存：
hibernate是一个线程对应一个session，一个线程可以看成一个用户。也就是说session级缓存(一级缓存)只能给一个线程用，别的线程用不了，一级缓存就是和线程绑定了。
hibernate一级缓存生命周期很短，和session生命周期一样，一级缓存也称session级的缓存或事务级缓存。如果tb事务提交或回滚了，我们称session就关闭了，生命周期结束了。
缓存和连接池的区别：缓存和池都是放在内存里，实现是一样的，都是为了提高性能的。但有细微的差别，池是重量级的，里面的数据是一样的，比如一个池里放100个Connection连接对象，这个100个都是一样的。缓存里的数据，每个都不一样。比如读取100条数据库记录放到缓存里，这100条记录都不一样。
二级缓存：
二级缓存需要sessionFactory来管理，它是进初级的缓存，所有人都可以使用，它是共享的。二级缓存比较复杂，一般用第三方产品。hibernate提供了一个简单实现，用Hashtable做的，只能作为我们的测试使用，商用还是需要第三方产品。

三、jsp用法
<c:set var="states" value="<%=com.bsi.action.support.StateUtils.getMapViewStateCnByViewState() %>" scope="request"/>
<s:select list="#request.states" name="state" id="state" value="state" headerKey="" headerValue="==请选择=="/>

<s:set name="states" value="#{'':'--请选择--','0':'新建','1':'已提交','2':'受理中','20':'审核中','21':'办结'}" />
<s:select list="#states" name="state" id="state" value="state" headerKey="" headerValue="==请选择=="/>


四、maven
maven的用途：
maven是一个项目构建和管理的工具，提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。
maven的好处在于可以将项目过程规范化、自动化、高效化以及强大的可扩展性
利用maven自身及其插件还可以获得代码检查报告、单元测试覆盖率、实现持续集成等等。


</2014-7-2>

<2014-7-3>
一、js用法
function addLiked(){
	if(flag){
		alert("正在收藏，请等待...");
		return ;
	}
	flag = true;
	var creator='${userInfo.loginid}';
	var name=parent.window.framemenu.getName();
	if(name=='undefined' || name=="" || name==null ){
		alert("请点击所要收藏的菜单!");
		flag=false;
		return;
	}
	name=encodeURI(name.substring(1).trim());  
	name=encodeURI(name);
	var href=parent.window.framemenu.getHref();
	 $.ajax({
		   type: "GET",
		   url: "http://192.168.31.226/webInterface/linked_save?callback=backSuccess",
		   dataType : "jsonp" ,
		   data: "creator="+creator+"&name="+name+"&href="+href
		});
  }
function backSuccess(date){
	  if(date.flag == 1){
		  alert("提交成功");
	  }else{
		  alert(date.msg);
	  }
	  flag = false;
  }
 
 二、JSON和JSONP
说到AJAX就会不可避免的面临两个问题，第一个是AJAX以何种格式来交换数据？第二个是跨域的需求如何解决？这两个问题目前都有不同的解决方案，比如数据可以用自定义字符串或者用XML来描述，跨域可以通过服务器端代理来解决。
但到目前为止最被推崇或者说首选的方案还是用JSON来传数据，靠JSONP来跨域。而这就是本文将要讲述的内容。
JSON(JavaScript Object Notation)和JSONP(JSON with Padding)虽然只有一个字母的差别，但其实他们根本不是一回事儿：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。我们拿最近比较火的谍战片来打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法。
JSON是一种基于文本的数据交换方式，或者叫做数据描述格式
JSON实例：
// 描述一个人 
var person = {
    "Name": "Bob",
    "Age": 32,
    "Company": "IBM",
    "Engineer": true
}
// 获取这个人的信息 
var personAge = person.Age;
// 描述几个人 
var members = [
    {
        "Name": "Bob",
        "Age": 32,
        "Company": "IBM",
        "Engineer": true
    },
    {
        "Name": "John",
        "Age": 20,
        "Company": "Oracle",
        "Engineer": false
    },
    {
        "Name": "Henry",
        "Age": 45,
        "Company": "Microsoft",
        "Engineer": false
    }
]
// 读取其中John的公司名称 
var johnsCompany = members[1].Company;
// 描述一次会议 
var conference = {
    "Conference": "Future Marketing",
    "Date": "2012-6-1",
    "Address": "Beijing",
    "Members":
    [
        {
            "Name": "Bob",
            "Age": 32,
            "Company": "IBM",
            "Engineer": true
        },
        {
            "Name": "John",
            "Age": 20,
            "Company": "Oracle",
            "Engineer": false
        },
        {
            "Name": "Henry",
            "Age": 45,
            "Company": "Microsoft",
            "Engineer": false
        }
    ]
}
// 读取参会者Henry是否工程师 
var henryIsAnEngineer = conference.Members[2].Engineer;
什么是JSONP：
其实网上关于JSONP的讲解有很多，但却千篇一律，而且云里雾里，对于很多刚接触的人来讲理解起来有些困难，小可不才，试着用自己的方式来阐释一下这个问题，看看是否有帮助。
1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；
2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如<script>、<img>、<iframe>）；
3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；
4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；
5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。
6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。
7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。
　　如果对于callback参数如何使用还有些模糊的话，我们后面会有具体的实例来讲解。
　　JSONP的客户端具体实现：
　　不管jQuery也好，ExtJs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现：
　　1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。
　　远程服务器remoteserver.com根目录下有个remote.js文件代码如下：
alert('我是远程文件'); 
　　本地服务器localserver.com下有个jsonp.html页面代码如下：
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>
</body>
</html> 
　　毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。
 
　　2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。
 
　　jsonp.html页面代码如下：
 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript">
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
    </script>
    <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>
</body>
</html> 
　　remote.js文件代码如下：
 
localHandler({"result":"我是远程js带来的数据"}); 
　　运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。
 
　　3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。
 
　　看jsonp.html页面的代码：
 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript">
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function(data){
        alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&callback=flightHandler";
    // 创建script标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script);
    </script>
</head>
<body>
</body>
</html> 
　　这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。
 
　　我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。
 
　　OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：
 
flightHandler({
    "code": "CA1998",
    "price": 1780,
    "tickets": 5
}); 
　　我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！
 
　　4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。
 
　　什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）：
 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" >
 <head>
     <title>Untitled Page</title>
      <script type="text/javascript" src=jquery.min.js"></script>
      <script type="text/javascript">
     jQuery(document).ready(function(){
        $.ajax({
             type: "get",
             async: false,
             url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998",
             dataType: "jsonp",
             jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
             jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据
             success: function(json){
                 alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');
             },
             error: function(){
                 alert('fail');
             }
         });
     });
     </script>
     </head>
  <body>
  </body>
 </html> 
　　是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？
 
　　1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；
 
　　2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<script>标签来调用服务器提供的js脚本。
 
　　3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。
 
　　4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。
 
　　总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！


</2014-7-3>

<2014-7-7>
一、存储过程（http://blog.csdn.net/x125858805/article/details/7581806）
create or replace procedure LLH_COUNT
as
V_TOTAL number(10);
begin
  select count(*) into V_TOTAL from t_video_course;
  DBMS_OUTPUT.put_line(''||V_TOTAL);
end;
执行
execute LLH_COUNT;
exec llh_count;
begin llh_count ;end;
授权：
grant execute on LLH_COUNT to RMSUSER;
删除存储过程：
drop procedure LLH_COUNT;

登录SCOTT账户：
GRANT EXECUTE ON EMP_COUNT TO STUDENT
登录STUDENT账户： 
SET SERVEROUTPUT ON  
        BEGIN  
        SCOTT.EMP_COUNT;   
        END;  

-------------
CREATE OR REPLACE PROCEDURE EMP_LIST   
        AS  
         CURSOR emp_cursor IS    
        SELECT empno,ename FROM emp;   
        BEGIN  
FOR Emp_record IN emp_cursor LOOP      
    DBMS_OUTPUT.PUT_LINE(Emp_record.empno||Emp_record.ename);   
        END LOOP;   
        EMP_COUNT;   
        END;  

-------------
CREATE OR REPLACE PROCEDURE CHANGE_SALARY(P_EMPNO IN NUMBER DEFAULT 7788,P_RAISE NUMBER DEFAULT 10)   
        AS  
         V_ENAME VARCHAR2(10);   
V_SAL NUMBER(5);   
        BEGIN  
        SELECT ENAME,SAL INTO V_ENAME,V_SAL FROM EMP WHERE EMPNO=P_EMPNO;   
         UPDATE EMP SET SAL=SAL+P_RAISE WHERE EMPNO=P_EMPNO;   
         DBMS_OUTPUT.PUT_LINE('雇员'||V_ENAME||'的工资被改为'||TO_CHAR(V_SAL+P_RAISE));   
COMMIT;   
        EXCEPTION   
         WHEN OTHERS THEN  
        DBMS_OUTPUT.PUT_LINE('发生错误，修改失败！');   
        ROLLBACK;   
        END; 
-----------
存储函数
CREATE OR REPLACE FUNCTION GET_EMP_NAME(P_EMPNO NUMBER DEFAULT 7788)   
        RETURN VARCHAR2   
        AS  
         V_ENAME VARCHAR2(10);   
        BEGIN  
        ELECT ENAME INTO V_ENAME FROM EMP WHERE EMPNO=P_EMPNO;   
RETURN(V_ENAME);   
EXCEPTION   
 WHEN NO_DATA_FOUND THEN  
  DBMS_OUTPUT.PUT_LINE('没有该编号雇员！');   
  RETURN (NULL);   
 WHEN TOO_MANY_ROWS THEN  
  DBMS_OUTPUT.PUT_LINE('有重复雇员编号！');   
  RETURN (NULL);   
 WHEN OTHERS THEN  
  DBMS_OUTPUT.PUT_LINE('发生其他错误！');   
  RETURN (NULL);   
END;  

-----------
存储过程和函数的查看 
DESCRIBE USER_SOURCE 
名称                                      是否为空? 类型   
        ------------------------------------------------------------- -------------   
 NAME                                               VARCHAR2(30)   
 TYPE                                               VARCHAR2(12)   
 LINE                                               NUMBER   
 TEXT                                               VARCHAR2(4000)  
里面按行存放着过程或函数的脚本，NAME是过程或函数名，TYPE 代表类型(PROCEDURE或FUNCTION)，LINE是行号，TEXT 为脚本。

select TEXT  from user_source WHERE NAME='EMP_COUNT'; 

二、js用法
为什么onclick中要加上return才能判断成功 才不会继续运行下去 
为什么直接写onclick="checkForm()" 注册的错误格式还会继续提交给服务器
JAVASCRIPT在事件中调用函数时用return返回值实际上是对window.event.returnvalue进行设置，而该值决定了当前操作是否继续。
当返回的是true时，将继续操作。
当返回是false时，将中断操作。
而直接执行时（不用return）。将不会对window.event.returnvalue进行设置
所以会默认地继续执行操作
详细说明如下：
例如：
当在 <a href="abc.htm" onclick="return add_onclick()">Open</a> 中
如果函数 add_onclick() 返回 true, 那么 页面就会打开 abc.htm
否则, (返回 false), 那么页面不会跳转到 abc.htm, 只会执行你的 add_onclick() 函数里的内容. (add_onclick函数中控制页面转到 abc.htm除外

)
而 <a href="abc.htm" onclick="add_onclick()">Open</a>
不管 add_onclick() 返回什么值, 都会在执行完 add_onclick 后打开页面 abc.htm

.toggle用法：
toggle() 方法切换元素的可见状态。
如果被选元素可见，则隐藏这些元素，如果被选元素隐藏，则显示这些元素。
$(".fint").toggle(function(){
var panel=$(".panel").show();
$(".panel").slideUp("slow");
$(this).addClass('dow')
},
function(){
$(".panel").slideDown("slow");
$(this).removeClass('dow');
});

$(document).ready(function(){
  $(".btn1").click(function(){
  $("p").toggle();
  });
});
三、sql语句
merge into lic_selfzz_elec m 
using (select c.id_code, e.alltype
                                 from elec_certificate e
                                 left join cm_person c
                                   on e.user_id = c.personid
                                where e.lice_state = '1'
                                  and e.user_id not in
                                      (select t.user_id
                                         from (select count(c.user_id) countnum,
                                                      c.user_id
                                                 from elec_certificate c
                                                where c.lice_state = '1'
                                                group by c.user_id) t
                                        where t.countnum > 1)) n

  ON (m.id_code = n.id_code)
  WHEN MATCHED THEN 
  update set m.licencetype = n.alltype
-----------
MERGE INTO products p   
 USING newproducts np   
    ON (p.product_id = np.product_id)   
    WHEN MATCHED THEN  
    UPDATE  
     SET p.product_name = np.product_name,   
     p.category = np.category   
    WHERE p.category = 'DVD'  
    WHEN NOT MATCHED THEN  
     INSERT  
     VALUES (np.product_id, np.product_name, np.category)   
    WHERE np.category != 'BOOKS'  
</2014-7-7>

<2014-7-8>
一、java类
private static final Logger LOGGER = Logger.getLogger(FileUtils.class);
private static Lock lock = new ReentrantLock();
public static void createFile(String filePath) {
	lock.lock();
	try {
		LOGGER.info("创建文件=>" + filePath);
		File file = new File(filePath);
		if (!file.exists()) {
			file.createNewFile();
		}
	} catch(IOException ex) {
		LOGGER.error(ex.getMessage(), ex);
	} finally {
		lock.unlock();
	}
}

二、pom.xml问题
cmd命令安装jar
mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.2.0 -Dpackaging=jar -Dfile=C:\Users\Administrator\Desktop\ojdbc14-10.2.0.2.0.jar

三、配置（http://wenku.baidu.com/view/0827eb1cff00bed5b8f31d07.html）
Tomcat连接池配置及spring引用方式    我这里以tomcat6为例（低版本可能有些许差别），使用oracle10g数据库（其他库类似），在spring中引用。 
1 准备工作  配置之前，先将oracle10g的数据库驱动包ojdbc14.jar放到tomcat目录下的lib文件夹中  
2 在Tomcat中配置连接池  Tomcat连接池配置的方式很多，这里介绍两种。  
2.1在context.xml中配置连接池  在tomcat目录下的conf文件夹中，修改context.xml文件，在context标签之间添加Resource标签如下    
<Context>      
<!-- Default set of monitored resources -->  <WatchedResource>WEB-INF/web.xml</WatchedResource>      
<Valve className="org.apache.catalina.valves.CometConnectionManagerValve" />  <Resource name="jdbc/oracleTest"      auth="Container"       type="javax.sql.DataSource"       driverClassName="oracle.jdbc.driver.OracleDriver"      url="jdbc:oracle:thin:@ip:1521:oral"      username="zhangsan"      password="sdfsdf"      maxActive="100"      maxIdle="30"            maxWait="10000"/>   
</Context> 

2.2在server.xml中配置连接池  
如果你在conf文件夹中的server.xml文件里像如下这样配置了全局context：   
<Host name="localhost"  appBase="webapps" unpackWARs="true" autoDeploy="true"  xmlValidation="false" xmlNamespaceAware="false">  
<Context docBase="E:\projects\test\WebRoot"   path="" debug="0" crossContext="true" >   
</Context>    
</Host>   
也可以将2.1中的Resource标签添加到这里的context下，变成下边这样。 
<Host name="localhost"  appBase="webapps" unpackWARs="true" autoDeploy="true"  xmlValidation="false" xmlNamespaceAware="false">  
<Context docBase="E:\projects\test\WebRoot"   path="" debug="0" crossContext="true" >    
<Resource name="jdbc/oracleTest "    auth="Container"     type="javax.sql.DataSource"      driverClassName="oracle.jdbc.driver.OracleDriver"     url="jdbc:oracle:thin:@ip:1521:oral"     username="zhangsan"      password="sdfsdf"    maxActive="100"    maxIdle="30"      maxWait="10000"    />   </Context>        
</Host>  
3 Spring中引用数据源  引用方式也很简单，只需要将spring配置文件中关于数据源配置的标签替换成下边这样既可   
<bean id="dataSource"  class="org.springframework.jndi.JndiObjectFactoryBean">           <property name="jndiName">               <value>java:comp/env/jdbc/oracleTest</value>                  
</property>      
</bean>  其中jdbc/oracleTest与我们在上边定义的Resource名字对应即可

四、tiles框架（http://www.cnblogs.com/laoyangHJ/articles/tilesframe2.html）
如果您发现自己在多个页面上重复相同的 HTML 代码，就可考虑对那些页面使用 tile 布局。类似地，如果在不同页面上的不同地方使用相同的 HTML 或 JSP 标签，这种情形也很适合使用 tile 来创建小型可视组件。
将 tile 标签库导入 JSP，同时导入需要的其他任何标签库：
<%@ taglib uri="/WEB-INF/struts-html.tld" prefix="html" %>
<%@ taglib uri="/WEB-INF/struts-bean.tld" prefix="bean" %>
<%@ taglib uri="/WEB-INF/struts-tiles.tld" prefix="tiles" %>
要使用 tile 标签库，不要忘了包括 web.xml文件中的标签库：
<taglib>
 <taglib-uri>/WEB-INF/struts-tiles.tld</taglib-uri>
 <taglib-location>/WEB-INF/struts-tiles.tld
 </taglib-location>
</taglib>

<html>
<head>
 <title>
	 <tiles:getAsString name="title" ignore="true"/>
 </title>
</head>
该代码中使用了tiles:getAsString 标签来显示字符串参数。您不仅能够传递字符串参数，而且能够传递要插入这个页面的其他页面。这里假设调用 JSP 页面向这个 tile 布局传递了一个标题；否则，标题将是空白。
ignore 属性如果为 true，这意味着在缺失该属性的情况下忽略它。否则，如果 ignore 属性为 false，那么在没有传递该参数的情况下，Tiles 框架将抛出异常，页面将不会显示出来（false 是默认值）。
要插入内容 JSP，可使用 tiles:insert标签，它插入该框架作为 tile 来引用的任何页面或 Web 资源。这个标签实际上在 tile 布局中定义了一个区域。 记住，tile 布局的目标是将 tile 布置到该布局中。
tiles:insert attribute="content"/>

<tiles:insert attribute="header" ignore="true">
       <tiles:put name="title" 
                  beanName="title" beanScope="tile"/>
</tiles:insert>
tiles:put 标签将这个 tile 布局范围内的 tile 参数放进页眉 tile 的范围。然后页眉 tile 就能够像 tile 布局所做的那样，通过 tiles:getAsString 标签来使用这个参数。参数名称就是页眉的 tile 范围内的属性名称。 bean 参数是当前范围内（siteLayout.jsp）的 bean 的名称。 beanScope 是您在其中查找这个属性的范围（可能的值是页面、tile、请求、会话和应用程序）。 您可以从任何范围向该 tile 传递 bean。
<%@ taglib uri="/WEB-INF/struts-html.tld" prefix="html" %>
 <%@ taglib uri="/WEB-INF/struts-bean.tld" prefix="bean" %>
 <%@ taglib uri="/WEB-INF/struts-tiles.tld" prefix="tiles" %>

 <html>
   <head>
     <title>
         <tiles:getAsString name="title" ignore="true"/>
     </title>
   </head>
   <body>
     <table width="500" border="0" cellspacing="0" cellpadding="0">

       <tr bgcolor="#36566E"> 
         <td height="68" width="48%"> 
           <div align="left">
             <img src="images/hp_logo_rickhightower.gif" 
                  width="220" height="74">
           </div>
         </td>
       </tr>
       <tr>
         <td height="68" width="2000">  
             <tiles:insert attribute="header" ignore="true">
                <tiles:put name="title" 
                           beanName="title" beanScope="tile"/>
             </tiles:insert>
          </td>   
       </tr>
       <tr>
         <td>
             <div align="center">
             <tiles:insert attribute="content"/>
             </div>
         </td>
       </tr>
       <tr>
         <td>
             <tiles:insert attribute="footer" ignore="true"/>
         </td>
       </tr>
     </table>
   </body>
 </html>

<%@ taglib uri="/WEB-INF/struts-tiles.tld" prefix="tiles" %>
 <tiles:insert page="/siteLayout.jsp" flush="true">

     <tiles:put name="title" type="string"
                      value="Get Rick Hightower Stock Quote" /> 
     <tiles:put name="header" value="/header.jsp" />
     <tiles:put name="footer" value="/footer.jsp" />
     <tiles:put name="content" value="/indexContent.jsp"/>
 </tiles:insert>
page 属性指定了上一节中定义的 tile 布局。如果 flush 属性被设置为 true，这个 tile（以及到目前为止的页面）将在页面的其余部分之前（或在缓冲区满而迫使执行刷新时）写到浏览器。
<%@ taglib uri="/WEB-INF/struts-html.tld" prefix="html" %>
 <%@ taglib uri="/WEB-INF/struts-bean.tld" prefix="bean" %>

 <html:form action="Lookup"> 
   <table width="45%" border="0">
     <tr>
       <td><bean:message key="app.symbol" />:</td>
       <td><html:text property="symbol" /></td>
     </tr>
     <tr>
       <td colspan="2" align="center"><html:submit /></td>
     </tr>
   </table>
 </html:form>

 <%@ taglib uri="/WEB-INF/struts-bean.tld" prefix="bean" %>
 <%@ taglib uri="/WEB-INF/struts-tiles.tld" prefix="tiles" %>

 <tiles:insert page="/siteLayout.jsp" flush="true">
     <tiles:put name="title" type="string" value="Rick Hightower Stock Quote" /> 
     <tiles:put name="header" value="/header.jsp" />
     <tiles:put name="footer" value="/footer.jsp" />
     <tiles:put name="content" type="string">
            <bean:message key="app.price"/>
            <%= request.getAttribute("PRICE") %>
     </tiles:put>
 </tiles:insert>
(存在这样一条规则：不要重复您自己（Don't repeat yourself，DRY）)
<tiles-definitions>
   <definition name="siteLayoutDef" path="/siteLayout.jsp">
     <put name="title" value="Rick Hightower Stock Quote System" /> 
     <put name="header" value="/header.jsp" />
     <put name="footer" value="/footer.jsp" />
     <put name="content" type="string">
        Content goes here
     </put>
   </definition>
</tiles-definitions>
这个模块的所有 tile 定义都将定义在 tiles-definition 元素内。
definition 元素指定一个 tile 定义。上面定义的定义在功能上等价于前面定义的 JSP 版本。注意该定义的属性稍有区别：使用 name 而不是 id，以及使用 path 而不是 page。（很气人，不是吗？）如果您知道如何定义一个基于 JSP 的定义，那么定义基于 XML 的定义将证明只是小孩子玩的游戏，因为它们在形式和功能上几乎是完全相同的。
<%@ taglib uri="/WEB-INF/struts-tiles.tld" prefix="tiles" %>
 <tiles:insert definition="siteLayoutDef">
     <tiles:put name="title" type="string" 
                value="Get Rick Hightower Stock Quote 3" /> 
     <tiles:put name="content" value="indexContent3.jsp"/>
 </tiles:insert>


五、mybatis框架
MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis 消除
了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML
或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java
对象）映射成数据库中的记录。
每个MyBatis应用程序主要都是使用SqlSessionFactory实例的，一个SqlSessionFactory实例可以通过SqlSessionFactoryBuilder获得。SqlSessionFactoryBuilder可以从一个xml配置文件或者一个预定义的配置类的实例获得。

六、tomcat配置数据源<JNDI>
添加到context.xml
<Context>
<Resource acquireIncrement="1" auth="Container" description="jdbc/oracle" driverClass="oracle.jdbc.driver.OracleDriver" factory="org.apache.naming.factory.BeanFactory" jdbcUrl="jdbc:oracle:thin:@10.8.9.244:1521:orcl" maxPoolSize="15" minPoolSize="2" name="jdbc/oracle" password="rmsuser" type="com.mchange.v2.c3p0.ComboPooledDataSource" user="rmsuser"/>
</Context>

添加到applicationContext.xml:（jdbc/oracle）
<!-- dataSource -->
<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
	<property name="jndiName" value="java:comp/env/jdbc/oracle"/>
</bean>

七、eclipse把一个工程引入另一个工程
Properties --> Java Build Path --> Project 添加项目
Properties --> Java Build Path --> Source 检查路径是否正确
（路径：F:\whty\rmscommon\src）

八、java类使用
public static List<String> docList = Arrays.asList("txt", "pdf", "doc", "docx", "xls", "xlsx", "ppt", "pptx");

private static final Logger LOGGER = Logger.getLogger(JsonHttpMessageConverter.class);
private ObjectMapper objectMapper = new ObjectMapper();

------（http://www.tuicool.com/articles/VnAFZje）
private Gson gson = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().setDateFormat("yyyy-MM-dd HH:mm:ss").create();
--例子：
Employee employee = new Employee();
employee.setId(1);
employee.setFirstName("Lokesh");
employee.setLastName("Gupta");
employee.setRoles(Arrays.asList("ADMIN", "MANAGER"));
Gson gson = new Gson();
System.out.println(gson.toJson(employee));
输出:
{"id":1,"firstName":"Lokesh","lastName":"Gupta","roles":["ADMIN","MANAGER"]}
--
Gson gson = new Gson();
System.out.println(
  gson.fromJson("{'id':1,'firstName':'Lokesh','lastName':'Gupta','roles':['ADMIN','MANAGER']}", 
  Employee.class));
输出:
Employee [id=1, firstName=Lokesh, lastName=Gupta, roles=[ADMIN, MANAGER]]
------
public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");
super(new MediaType("application", "json", DEFAULT_CHARSET));
获得java类型：
protected JavaType getJavaType(Class<?> clazz) {
	return TypeFactory.type(clazz);
}

九、Spring之ContextLoaderListener的作用 
使用spring除了添加必要的jar包,另外在web.xml一定要加上启动spring的监听器,这样配置在xml文件中的bean才会初始化 
<listener>  
	<listener-class>  
		org.springframework.web.context.ContextLoaderListener  
	</listener-class>  
</listener> 
它会默认查找位于:WEB-INF/下的是否有一个文件名称为:applicationContext.xml 
但在很多项目中可能会把配置文件集中管理,常见位置在:classpath下面,这样的话,你要在web.xml中在配置另外一个节点名称: 
<context-param>  
	<param-name>  
		contextConfigLocation  
	</param-name>  
	<param-value>  
		classpath*:applicationContext.xml  
	</param-value>  
</context-param>
常见可能是这样:/WEB-INF/classes/applicationContext-*.xml 
总之它是使用spring必须要配置的元素,一定不要少了

十、JNDI
基于JNDI的应用开发 
JNDI（The Java Naming and Directory Interface，Java命名和目录接口）是一组在Java应用中访问命名和目录服务的API.命名服务将名称和对象联系起来，使得我们可以用名称访问对象。目录服务是一种命名服务，在这种服务里，对象不但有名称，还有属性。

命名或目录服务使你可以集中存储共有信息，这一点在网络应用中是重要的，因为这使得这样的应用更协调、更容易管理。例如，可以将打印机设置存储在目录服务中，以便被与打印机有关的应用使用。

十一、@注入
@javax.annotation.Resource
private ResourceService resourceService;
@javax.annotation.Resource
private ResourceDao resourceDao;

Spring 框架核心的思想就是建立一个 Java 对象的大工厂，用户只要给工厂一个指令，
工厂就能将用户需要的对象根据配置文件组装好返还给用户。用户需要做的许多工作则可以写成简单的配置文件。

十二、xml配置
<!-- servlet mapping -->
<servlet-mapping>
	<servlet-name>DispatcherServlet</servlet-name>
	<url-pattern>*.do</url-pattern>
</servlet-mapping>
<servlet-mapping>
	<servlet-name>DispatcherServlet</servlet-name>
	<url-pattern>*.htm</url-pattern>
</servlet-mapping>

</2014-7-8>

<2014-7-9>
一、mybatic映射Entity文件和sql操作
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="ResourceMapper">
    <!-- result map -->
    <resultMap type="Resource" id="ResourceMap">
        <result column="RES_ID" property="resId"/>
        <result column="TITLE" property="title"/>
        <result column="KEYWORD" property="keyword"/>
        <result column="INTRO" property="intro"/>
        <result column="LANGUAGE_ID" property="languageId"/>
        <result column="LANGUAGE_NAME" property="languageName"/>
        <result column="RES_FORM" property="resForm"/>
        <result column="URL" property="url"/>
        <result column="IS_EXCELLENT" property="isExcellent"/>
        <result column="STATUS" property="status"/>
        <result column="FID" property="fid"/>
        <result column="PROVIDER_ID" property="providerId"/>
        <result column="PROVIDER_NAME" property="providerName"/>
        <result column="CREATOR_ID" property="creatorId"/>
        <result column="CREATE_TIME" property="createTime"/>
        <result column="MODIFYIER_ID" property="modifierId"/>
        <result column="MODIFY_TIME" property="modifyTime"/>
        <result column="FILE_NAME_LOCAL" property="fileName"/>
        <result column="FILE_LENGTH" property="fileLength"/>
        <result column="FILE_EXT" property="fileExt"/>
        <result column="FILE_ID" property="fileId"/>
        <result column="FLASH_FILE_ID" property="flashFileId"/>
        <result column="FLASH_FILE_LENGTH" property="flashFileLength"/>
        <result column="FLASH_FILE_EXT" property="flashFileExt"/>
        <result column="FLASH_FILE_PATH" property="flashFilePath"/>
        <result column="THUMBNAIL_FILE_ID" property="thumbnailFileId"/>
        <result column="THUMBNAIL_FILE_PATH" property="thumbnailFilePath"/>
        <result column="TOPIC_NAME" property="topicName"/>
        <result column="VIEW_COUNT" property="viewCount"/>
        <result column="COMMENT_COUNT" property="commentCount"/>
        <result column="DOWN_COUNT" property="downCount"/>
        <result column="SCORE" property="score"/>
        <result column="FILE_SIZE" property="fileSize"/>
    </resultMap>

    <!-- where clause -->
    <sql id="whereClause">
        <where>
            <if test="title != null and title != ''">
                res.TITLE like '%' || #{title} || '%'
            </if>
            <if test="keyword != null and keyword != ''">
            	AND res.KEYWORD like '%' || #{keyword} || '%'
            </if>
            <if test="creatorId != null and creatorId != ''">
            	AND res.CREATOR_ID=#{creatorId}
            </if>
            <if test="status != null and status != ''">
            	AND res.STATUS=#{status}
            </if>
            <if test="periodId != null and periodId != ''">
                AND per.PERIOD_ID=#{periodId}
            </if>
            <if test="subjectId != null and subjectId != ''">
                AND sub.SUBJECT_ID=#{subjectId}
            </if>
            <if test="editionId != null and editionId != ''">
                AND edi.EDITION_ID=#{editionId}
            </if>
            <if test="gradeId != null and gradeId != ''">
            	AND gra.GRADE_ID=#{gradeId}
            </if>
            <if test="volumeId != null and volumeId != ''">
            	AND vol.VOLUME_ID=#{volumeId}
            </if>
            <if test="textbookId != null and textbookId != ''">
                AND txt.TEXTBOOK_ID=#{textbookId}
            </if>
            <if test="chapterId != null and chapterId != ''">
            	AND cpt.CHAPTER_ID in (select CHAPTER_ID from T_CHAPTER start with CHAPTER_ID=#{chapterId} connect by prior CHAPTER_ID=CHAPTER_PID)
            </if>
            <if test="resClassId != null and resClassId != ''">
            	AND cla.RES_CLASS_ID=#{resClassId}
            </if>
            <if test="topicId != null and topicId != ''">
            	AND aca.TOPIC_ID in (select TOPIC_ID from T_ACADEMY_TOPIC start with TOPIC_ID=#{topicId} connect by prior TOPIC_ID=PARENT_ID)
            </if>
        </where>
    </sql>
    
    <sql id="orderClause">
    	<if test="orderBy != null and orderBy != ''">
    		order by res.${orderBy} desc
    	</if>
    </sql>

    <!-- select clause -->
    <sql id="selectClause">
        select res.*, 
        <if test="topicId != null and topicId != ''">
       		topic.TOPIC_NAME,
        </if>
        	attach.FILE_NAME_LOCAL,
	        attach.FILE_LENGTH,
	        attach.FILE_SIZE,
	        attach.FILE_EXT,
	        attach.FILE_ID,
	        attach.FLASH_FILE_ID,
	        attach.FLASH_FILE_PATH,
	        attach.FLASH_FILE_LENGTH,
	        attach.FLASH_FILE_EXT,
	        attach.THUMBNAIL_FILE_ID,
        	attach.THUMBNAIL_FILE_PATH
        from T_RESOURCE res left join T_ATTACH_FILE attach on res.FID=attach.FID
        <if test="periodId != null and periodId != ''">
        	inner join T_RES_PERIOD per on res.RES_ID=per.RES_ID
        </if>
        <if test="subjectId != null and subjectId != ''">
            inner join T_RES_SUBJECT sub on res.RES_ID=sub.RES_ID
        </if>
        <if test="editionId != null and editionId != ''">
            inner join T_RES_EDITION edi on res.RES_ID=edi.RES_ID
        </if>
        <if test="gradeId != null and gradeId != ''">
        	inner join T_RES_GRADE gra on res.RES_ID=gra.RES_ID
        </if>
        <if test="volumeId != null and volumeId != ''">
        	inner join T_RES_VOLUME vol on res.RES_ID=vol.RES_ID
        </if>
        <if test="textbookId != null and textbookId != ''">
            inner join T_RES_TEXTBOOK txt on res.RES_ID=txt.RES_ID
        </if>
        <if test="chapterId != null and chapterId != ''">
        	inner join T_RES_CHAPTER cpt on res.RES_ID=cpt.RES_ID
        </if>
        <if test="resClassId != null and resClassId != ''">
        	inner join T_RES_CLASS_RES cla on res.RES_ID=cla.RES_ID
        </if>
        <if test="topicId != null and topicId != ''">
        	inner join T_ACADEMY_RESOURCE aca on res.RES_ID=aca.RES_ID inner join T_ACADEMY_TOPIC topic on aca.TOPIC_ID=topic.TOPIC_ID
        </if>
        <include refid="whereClause"/>
        <include refid="orderClause"/>
    </sql>

    <!-- select one -->
    <select id="selectOne" parameterType="string" resultMap="ResourceMap">
        select t1.*,
		       t2.FILE_NAME_LOCAL,
		       t2.FILE_LENGTH,
		       t2.FILE_SIZE,
		       t2.FILE_EXT,
		       t2.FILE_ID,
		       t2.FLASH_FILE_ID,
		       t2.FLASH_FILE_LENGTH,
		       t2.FLASH_FILE_EXT,
		       t2.FLASH_FILE_PATH,
		       t2.THUMBNAIL_FILE_ID,
		       t2.THUMBNAIL_FILE_PATH,
		       t3.LANGUAGE_NAME,
		       t4.PROVIDER_NAME
		  from T_RESOURCE t1
		  left join T_ATTACH_FILE t2
		    on t1.FID = t2.FID
		  left join T_LANGUAGE t3
		    on t1.LANGUAGE_ID = t3.LANGUAGE_ID
		  left join T_RES_PROVIDER t4
		    on t1.PROVIDER_ID = t4.PROVIDER_ID
		 where t1.RES_ID = #{resId}
    </select>

    <!-- select list -->
    <select id="selectList" parameterType="Resource" resultMap="ResourceMap">
        <include refid="selectClause"/>
    </select>

    <!-- select for pagination -->
    <select id="selectForPagination" parameterType="hashmap" resultMap="ResourceMap">
        <include refid="CommonMapper.pageStart"/>
        <include refid="selectClause"/>
        <include refid="CommonMapper.pageEnd"/>
    </select>

    <!-- select count -->
    <select id="selectCount" parameterType="hashmap" resultType="int">
        select count(*) from (<include refid="selectClause"/>)
    </select>

    <!-- insert one -->
    <insert id="insertOne" parameterType="Resource">
        insert into T_RESOURCE (
        <trim suffixOverrides=",">
        	<if test="resId != null and resId != ''">
        		RES_ID,
        	</if>
        	<if test="title != null and title != ''">
            	TITLE,
            </if>
            <if test="keyword != null and keyword != ''">
            	KEYWORD,
            </if>
            <if test="intro != null and intro != ''">
            	INTRO,
            </if>
            <if test="languageId != null and languageId != ''">
            	LANGUAGE_ID,
            </if>
            <if test="resForm != null and resForm != ''">
            	RES_FORM,
            </if>
            <if test="url != null and url != ''">
            	URL,
            </if>
            <if test="isExcellent != null and isExcellent != ''">
            	IS_EXCELLENT,
            </if>
            <if test="status != null and status != ''">
            	STATUS,
            </if>
            <if test="textbookId != null and textbookId != ''">
            	TEXTBOOK_ID,
            </if>
            <if test="periodId != null and periodId != ''">
            	PERIOD_ID,
            </if>
            <if test="subjectId != null and subjectId != ''">
            	SUBJECT_ID,
            </if>
            <if test="gradeId != null and gradeId != ''">
            	GRADE_ID,
            </if>
            <if test="volumeId != null and volumeId != ''">
            	VOLUME_ID,
            </if>
            <if test="editionId != null and editionId != ''">
            	EDITION_ID,
            </if>
            <if test="fid != null and fid != ''">
            	FID,
            </if>
            <if test="providerId != null and providerId != ''">
            	PROVIDER_ID,
            </if>
            <if test="chapterId != null and chapterId != ''">
            	CHAPTER_ID,
            </if>
            <if test="creatorId != null and creatorId != ''">
            	CREATOR_ID
            </if>
        </trim>
        ) values (
        <trim suffixOverrides=",">
        	<if test="resId != null and resId != ''">
        		#{resId},
        	</if>
        	<if test="title != null and title != ''">
            	#{title},
            </if>
            <if test="keyword != null and keyword != ''">
            	#{keyword},
            </if>
            <if test="intro != null and intro != ''">
            	#{intro},
            </if>
            <if test="languageId != null and languageId != ''">
            	#{languageId},
            </if>
            <if test="resForm != null and resForm != ''">
            	#{resForm},
            </if>
            <if test="url != null and url != ''">
            	#{url},
            </if>
            <if test="isExcellent != null and isExcellent != ''">
            	#{isExcellent},
            </if>
            <if test="status != null and status != ''">
            	#{status},
            </if>
            <if test="textbookId != null and textbookId != ''">
            	#{textbookId},
            </if>
            <if test="periodId != null and periodId != ''">
            	#{periodId},
            </if>
            <if test="subjectId != null and subjectId != ''">
            	#{subjectId},
            </if>
            <if test="gradeId != null and gradeId != ''">
            	#{gradeId},
            </if>
            <if test="volumeId != null and volumeId != ''">
            	#{volumeId},
            </if>
            <if test="editionId != null and editionId != ''">
            	#{editionId},
            </if>
            <if test="fid != null and fid != ''">
            	#{fid},
            </if>
            <if test="providerId != null and providerId != ''">
            	#{providerId},
            </if>
            <if test="chapterId != null and chapterId != ''">
            	#{chapterId},
            </if>
            <if test="creatorId != null and creatorId != ''">
            	#{creatorId}
            </if>
        </trim>   
        )
    </insert>

    <!-- update one -->
    <update id="updateOne" parameterType="Resource">
        update T_RESOURCE
        <set>
            <if test="title != null">
                TITLE=#{title},
            </if>
            <if test="keyword != null">
                KEYWORD=#{keyword},
            </if>
            <if test="intro != null">
                INTRO=#{intro},
            </if>
            <if test="languageId != null">
                LANGUAGE_ID=#{languageId},
            </if>
            <if test="resForm != null">
                RES_FORM=#{resForm},
            </if>
            <if test="url != null">
                URL=#{url},
            </if>
            <if test="isExcellent != null">
                IS_EXCELLENT=#{isExcellent},
            </if>
            <if test="status != null">
                STATUS=#{status},
            </if>
            <if test="fid != null">
                FID=#{fid},
            </if>
            <if test="providerId != null">
                PROVIDER_ID=#{providerId},
            </if>
            <if test="score != null">
            	SCORE=#{score}
            </if>
        </set>
        where RES_ID=#{resId}
    </update>

    <!-- delete one -->
    <delete id="deleteOne" parameterType="string">
        delete from T_RESOURCE where RES_ID=#{resId}
    </delete>
    
    <update id="addViewCount" parameterType="string">
    	update T_RESOURCE set VIEW_COUNT=VIEW_COUNT+1 where RES_ID=#{resId}
    </update>
    
    <update id="addCommentCount" parameterType="string">
    	update T_RESOURCE set COMMENT_COUNT=COMMENT_COUNT+1 where RES_ID=#{resId}
    </update>
</mapper>

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="CommonMapper">
	<!-- oracle分页查询 -->
	<sql id="pageStart">
		<![CDATA[
			select * from (select rownum as rnum, t.* from (
		]]>
	</sql>
	<sql id="pageEnd">
		<![CDATA[
			) t where rownum <= #{curPage}*#{numPerPage}) where rnum > (#{curPage}-1)*#{numPerPage}
		]]>
	</sql>
</mapper>

二、jquery事件用法
hover(Function, Function)    
当鼠标move over时触发第一个function，当鼠标move out时触发第二个function
样式：<style>.red{color:#FF0000}</style>
Html代码： <div id="a">sdf</div>
jQuery代码及效果
$(function(){
  $("#a").hover(function(){$(this).addClass("red");},
                            function(){ $(this).removeClass("red"); 
                          });
})
最终效果是当鼠标移到id为a的层上时图层增加一个red样式，离开层时移出red样式
---------
toggle(Function, Function)    
当匹配元素第一次被点击时触发第一个函数，当第二次被点击时触发第二个函数
样式：<style>.red{color:#FF0000}</style>
Html代码： <div id="a">sdf</div>
jQuery代码及效果
$(function(){
  $("#a"). toggle (function(){$(this).addClass("red");},
                              function(){ $(this).removeClass("red"); 
                            });
})

最终效果是当鼠标点击id为a的层上时图层增加一个red样式，离开层时移出red样式
---------
bind(type, fn)  
用户将一个事件和触发事件的方式绑定到匹配对象上。
trigger(type)   
用户触发type形式的事件。$("p").trigger("click")
还有：unbind()   unbind(type)    unbind(type, fn)
Dynamic event(Function)    
---------
绑定和取消绑定提供函数的简捷方式
例：
$("#a").bind("click",function() { 
					   $(this).addClass("red");
})

也可以这样写：
　　$("#a").click(function() { 
                        $(this).addClass("red");
});

　　最终效果是当鼠标点击id为a的层上时图层增加一个red样式，

jQuery提供的函数 
用于browers事件
error(fn)    load(fn)     unload(fn)    resize(fn)    scroll(fn)

用于form事件
change(fn)    select(fn)    submit(fn)

用于keyboard事件
keydown(fn)    keypress(fn)    keyup(fn)

用于mouse事件
click(fn)    dblclick(fn)    mousedown(fn)   mousemove(fn)
mouseout(fn)  mouseover(fn)     mouseup(fn)

用于UI事件
blur(fn)    focus(fn)

以上事件的扩展再扩展为5类
举例，click(fn) 扩展 click()  unclick()  oneclick(fn)  unclick(fn)
click(fn)：增加一个点击时触发某函数的事件
click()：可以在其他事件中执行匹配对象的click事件。
unclick ()：不执行匹配对象的click事件。
oneclick(fn)：只增加可以执行一次的click事件。
unclick (fn)：增加一个点击时不触发某函数的事件。
上面列举的用于browers、form、keyboard、mouse、UI的事件都可以按以上方法扩展。

三、XML CDATA
CDATA 部分中的所有内容都会被解析器忽略。
CDATA 部分由 "<![CDATA[" 开始，由 "]]>" 结束：

PCDATA 指的是被解析的字符数据（Parsed Character Data）。
XML 解析器通常会解析 XML 文档中所有的文本。
当某个 XML 元素被解析时，其标签之间的文本也会被解析
解析器之所以这么做是因为 XML 元素可包含其他元素，就像这个例子中，其中的 <name> 元素包含着另外的两个元素(first 和 last)：
<name><first>Bill</first><last>Gates</last></name>
转义字符
非法的 XML 字符必须被替换为实体引用（entity reference）。
假如您在 XML 文档中放置了一个类似 "<" 字符，那么这个文档会产生一个错误，这是因为解析器会把它解释为新元素的开始。因此你不能这样写：
在 XML 中有 5 个预定义的实体引用：
&lt;	<	小于
&gt;	>	大于
&amp;	&	和号
&apos;	'	省略号
&quot;	"	引号
注释：严格地讲，在 XML 中仅有字符 "<"和"&" 是非法的。省略号、引号和大于号是合法的，但是把它们替换为实体引用是个好的习惯。
CDATA
术语 CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。
在 XML 元素中，"<" 和 "&" 是非法的。
"<" 会产生错误，因为解析器会把该字符解释为新元素的开始。
"&" 也会产生错误，因为解析器会把该字符解释为字符实体的开始。
某些文本，比如 JavaScript 代码，包含大量 "<" 或 "&" 字符。为了避免错误，可以将脚本代码定义为 CDATA。
CDATA 部分中的所有内容都会被解析器忽略。
CDATA 部分由 "<![CDATA[" 开始，由 "]]>" 结束：
CDATA 部分不能包含字符串 "]]>"。也不允许嵌套的 CDATA 部分。
标记 CDATA 部分结尾的 "]]>" 不能包含空格或折行。

四、mybatic动态SQL中trim标签使用
<trim suffixOverrides=",">
<trim suffix="" suffixOverrides=",">
mybatis insert 空属性用trim suffix="" suffixOverrides=","去多余的“，”
事实上trim标签有点类似于replace效果。
trim 属性
		prefix：前缀覆盖并增加其内容
		suffix：后缀覆盖并增加其内容
		prefixOverrides：前缀判断的条件
		suffixOverrides：后缀判断的条件


五、Oracle数据导入导出imp/exp命令 10g以上expdp/impdp命令
Oracle数据导入导出imp/exp就相当于oracle数据还原与备份。exp命令可以把数据从远程数据库服务器导出到本地的dmp文 件，imp命令可以把dmp文件从本地导入到远处的数据库服务器中。 利用这个功能可以构建两个相同的数据库，一个用来测试，一个用来正式使用。
执行环境：可以在SQLPLUS.EXE或者DOS（命令行）中执行，
 DOS中可以执行时由于 在oracle 8i 中  安装目录ora81BIN被设置为全局路径，
 该目录下有EXP.EXE与IMP.EXE文件被用来执行导入导出。
 oracle用java编写，SQLPLUS.EXE、EXP.EXE、IMP.EXE这两个文件有可能是被包装后的类文件。
 SQLPLUS.EXE调用EXP.EXE、IMP.EXE所包裹的类，完成导入导出功能。
 
下面介绍的是导入导出的实例。
数据导出：
 1 将数据库TEST完全导出,用户名system 密码manager 导出到D:/daochu.dmp中
   exp system/manager@TEST file=d:/daochu.dmp full=y
 2 将数据库中system用户与sys用户的表导出
   exp system/manager@TEST file=d:/daochu.dmp owner=(system,sys)
 3 将数据库中的表inner_notify、notify_staff_relat导出
    exp aichannel/aichannel@TESTDB2 file= d:/datanewsmgnt.dmp tables=(inner_notify,notify_staff_relat) 
 4 将数据库中的表table1中的字段filed1以"00"打头的数据导出
   exp system/manager@TEST file=d:/daochu.dmp tables=(table1) query=" where filed1 like '00%'"
 
  上面是常用的导出，对于压缩，既用winzip把dmp文件可以很好的压缩。
  也可以在上面命令后面 加上 compress=y 来实现。

数据的导入
 1 将D:/daochu.dmp 中的数据导入 TEST数据库中。
   imp system/manager@TEST  file=d:/daochu.dmp
   imp aichannel/aichannel@TEST  full=y  file=d:/datanewsmgnt.dmp ignore=y
   上面可能有点问题，因为有的表已经存在，然后它就报错，对该表就不进行导入。
   在后面加上 ignore=y 就可以了。
 2 将d:daochu.dmp中的表table1 导入
 imp system/manager@TEST  file=d:/daochu.dmp  tables=(table1)
 
 基本上上面的导入导出够用了。不少情况要先是将表彻底删除，然后导入。
 
注意：
 操作者要有足够的权限，权限不够它会提示。
 数据库时可以连上的。可以用tnsping TEST 来获得数据库TEST能否连上。

附录一：
 给用户增加导入数据权限的操作
 第一,启动sql*puls
 第二，以system/manager登陆
 第三，create user 用户名 IDENTIFIED BY 密码 （如果已经创建过用户，这步可以省略）
 第四，GRANT CREATE USER,DROP USER,ALTER USER ,CREATE ANY VIEW ,
   DROP ANY VIEW,EXP_FULL_DATABASE,IMP_FULL_DATABASE,
      DBA,CONNECT,RESOURCE,CREATE SESSION  TO 用户名字
 第五, 运行-cmd-进入dmp文件所在的目录,
      imp userid=system/manager full=y file=*.dmp
      或者 imp userid=system/manager full=y file=filename.dmp

 执行示例:
 F:WorkOracle_Databackup>imp userid=test/test full=y file=inner_notify.dmp

屏幕显示
Import: Release 8.1.7.0.0 - Production on 星期四 2月 16 16:50:05 2006
(c) Copyright 2000 Oracle Corporation.  All rights reserved.

连接到: Oracle8i Enterprise Edition Release 8.1.7.0.0 - Production
With the Partitioning option
JServer Release 8.1.7.0.0 - Production

经由常规路径导出由EXPORT:V08.01.07创建的文件
已经完成ZHS16GBK字符集和ZHS16GBK NCHAR 字符集中的导入
导出服务器使用UTF8 NCHAR 字符集 (可能的ncharset转换)
. 正在将AICHANNEL的对象导入到 AICHANNEL
. . 正在导入表                  "INNER_NOTIFY"          4行被导入
准备启用约束条件...
成功终止导入，但出现警告。
附录二：
 Oracle 不允许直接改变表的拥有者, 利用Export/Import可以达到这一目的.
  先建立import9.par,
  然后，使用时命令如下：imp parfile=/filepath/import9.par
  例 import9.par 内容如下：
        FROMUSER=TGPMS       
        TOUSER=TGPMS2     （注：把表的拥有者由FROMUSER改为TOUSER，FROMUSER和TOUSER的用户可以不同）          
        ROWS=Y
        INDEXES=Y
        GRANTS=Y
        CONSTRAINTS=Y
        BUFFER=409600
        file==/backup/ctgpc_20030623.dmp
        log==/backup/import_20030623.log 
在导入导出命令中加上feedback=1000可以让过程显示一个不断增多的“...”，以改变以往的闪烁的光标
New:
exp/imp已经很好用了，但是唯一的确定是速度太慢，如果1张表的数据有个百千万的，常常导入导出就长时间停在这个表这，但是从Oracle 10g开始提供了称为数据泵新的工具expdp/impdp，它为Oracle数据提供高速并行及大数据的迁移。

 imp/exp可以在客户端调用，但是expdp/impdp只能在服务端，因为在使用expdp/impdp以前需要在数据库中创建一个Directory
create directory dump_test as '/u01/oracle10g'；
grant read, write on directory dump_test to piner
然后就可以开始导入导出
expdp piner/piner directory=dump_test dumpfile=user.dmp  导出用户的数据
expdp piner/piner directory=dump_test dumpfile=table.dmp tables=test1,test2 导出表数据
impdp piner/piner directory=dump_test dumpfile=user.dmp 导入该用户数据
impdp piner/piner directory=dump_test dumpfile=table.dmp  导出表数据


六、拦截器
<!-- 面包屑拦截器 -->
<mvc:interceptor>
<mvc:mapping path="/jspxCourseList.htm"/> <!-- 教师培训课程列表页（教师网） -->
<mvc:mapping path="/yslyResList.htm"/> <!-- 影像词典资源列表页（央视龙优） -->
<mvc:mapping path="/zsdwkCourseList.htm"/> <!-- 知识点微课课程列表页（天闻数媒） -->
<mvc:mapping path="/ztljyResList.htm"/> <!-- 专题类资源列表页（上海远教） -->
<mvc:mapping path="/videoLessonDetail.htm"/> <!-- 视频课程详情页 -->
<mvc:mapping path="/resourceDetail.htm"/> <!-- 资源详情页 -->
<bean class="com.whty.rmsweb.common.interceptor.BreadCrumbsInterceptor">
	<property name="topicListPage">
		<list>
			<value>/jspxCourseList.htm</value>
			<value>/yslyResList.htm</value>
			<value>/zsdwkCourseList.htm</value>
			<value>/ztljyResList.htm</value>
		</list>
	</property>
</bean>
</mvc:interceptor>

public class BreadCrumbsInterceptor extends HandlerInterceptorAdapter {
   private List<String> topicListPage;
   @Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
			Object handler) throws Exception {
			}
    @Override
	public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
			Object handler, Exception ex) throws Exception {
			}
}

七、tiles框架
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title><tiles:insertAttribute name="title" ignore="true"/></title>
		<%@ include file="/WEB-INF/views/common/cssjs.jsp" %>
	</head>
	<body class="portal">
		<tiles:insertAttribute name="header"/>
		<div class="Main w1000 clearfix eduSource">
			<!--#面包削.start-->
			<tiles:insertAttribute name="breadcrumbs"/>
			<!--#面包削.over-->
			<tiles:insertAttribute name="topicMenu"/>
			<tiles:insertAttribute name="topicList"/>
		</div>
		<!--#pub_foot_js.start-->
		<tiles:insertAttribute name="footer"/>
		<!--#pub_foot_js.over-->
	</body>
</html>

八、Memcached
Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached基于一个存储键/值对的hashmap。其守护进程（daemon ）是用C写的，但是客户端可以用任何语言来编写，并通过memcached协议与守护进程通信。

九、Spring 使用 <tx:advice>和 <aop :config> 用来配置事务
(* com.evan.crm.service..*.*(..))中几个通配符的含义：
|第一个 * ―― 通配 任意返回值类型|
|第二个 * ―― 通配 包com.evan.crm.service下的任意class|
|第三个 * ―― 通配 包com.evan.crm.service下的任意class的任意方法|
|第二个 .. ―― 通配 方法可以有0个或多个参数|
综上：包com.evan.crm.service下的任意class的具有任意返回值类型、任意数目参数和任意名称的方法
<!-- tx advice 配置事务传播特性-->
<tx:advice id="txAdvice" transaction-manager="transactionManager">
	<tx:attributes>
		<tx:method name="add*" propagation="REQUIRED"/>
		<tx:method name="insert*" propagation="REQUIRED"/>
		<tx:method name="del*" propagation="REQUIRED"/>
		<tx:method name="remove*" propagation="REQUIRED"/>
		<tx:method name="update*" propagation="REQUIRED"/>
		<tx:method name="mod*" propagation="REQUIRED"/>
		<tx:method name="*" read-only="true"/>
	</tx:attributes>
</tx:advice>
	
<!-- aop config 配置哪些类的哪些方法参与事务-->
<aop:config>
	<aop:advisor advice-ref="txAdvice" pointcut="execution(* com.whty.rmsweb..*.*Service.*(..))" />
</aop:config>

</2014-7-9>
<2014-7-10>
一、solr（http://www.blogjava.net/RongHao/archive/2007/11/06/158621.html）
Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。
用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果；
Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。
文档通过Http利用XML 加到一个搜索集合中。查询该集合也是通过http收到一个XML/JSON响应来实现。它的主要特性
包括：高效、灵活的缓存功能，垂直搜索功能，高亮显示搜索结果，通过索引复制来提高可用性，提供一套强大Data Schema来定义字段，类型和设置文本分析，提供基于Web的管理界面等。
Solr它是一种开放源码的、基于 Lucene Java 的搜索服务器，易于加入到 Web 应用程序中。Solr 提供了层面搜索(就是统计)、命中醒目显示并且支持多种输出格式（包括XML/XSLT 和JSON等格式）。


(http://www.kankanews.com/ICkengine/archives/144911.shtml)
二、mongodb（http://www.cnblogs.com/lecaf/archive/2013/08/23/mongodb.html）


三、SecureCRT（跳板机）
这个远程连接的软件，很好的远程调试软件，比超级终端好用，我用的就是这个，你可以用这个来远程调试路由器，交换机等，也可以用来和你的虚拟机连接等。


四、tomcat部署solr（版本很重要）
1.将solr-4.7.2/example/webapps目录下的solr.war复制到tomcat的webapps目录中;
2.启动tomcat服务器，这时候会报错，暂时不用管，只是为了解压war包，启动完成后关闭Tomcat；
3.新建一个tomcat-solr文件夹（名称与位置随意），我建在了F盘下。
4.将solr-4.7.2/example/lib/ext/下的所有jar包复制到tomcat的lib目录中，一共5个，是solr的独立日志处理模块
5.tomcat-7.0.53\webapps\solr\WEB-INF找到web.xml文件中用于配置环境变量的标签，去掉注释，并修改环境变量为
<env-entry>
   <env-entry-name>solr/home</env-entry-name>
	<env-entry-value>F:/whty/MongoDB/solr/tomcat-solr</env-entry-value>
   <env-entry-type>java.lang.String</env-entry-type>
</env-entry>

浏览器输入：http://localhost:8080/solr就能看到solr的管理界面了
http://localhost:8080/solr/#/collection1/query进行查询结果的查看

五、Lucene 是什么
Lucene是一个基于Java的全文信息检索工具包，它不是一个完整的搜索应用程序，而是为你的应用程序提供索引和搜索功能。Lucene 目前是 Apache Jakarta(雅加达) 家族中的一个开源项目。也是目前最为流行的基于Java开源全文检索工具包。目前已经有很多应用程序的搜索功能是基于 Lucene ，比如Eclipse 帮助系统的搜索功能。Lucene能够为文本类型的数据建立索引，所以你只要把你要索引的数据格式转化的文本格式，Lucene 就能对你的文档进行索引和搜索。

六、solr导入数据
1.将下载下来的solr4.6的dist文件夹下的solr-dataimporthandler-4.6.0.jar和solr-dataimporthandler-extras-4.6.0.jar,数据库jdbc.jar放入tomcat该路径下F:\solr\tomcat7.0.27\webapps\solr\WEB-INF\lib
2.将F:\whty\MongoDB\solr\solr-4.7.2\example\example-DIH\solr下的所有文件复制到F:\whty\MongoDB\solr\tomcat-solr
3.修改tomcat-solr\solr\conf\solrconfig.xml,添加下面这段代码
<requestHandler name="/dataimport" class="org.apache.solr.handler.dataimport.DataImportHandler">
	 <lst name="defaults">
	 <str name="config">F:/whty/MongoDB/solr/tomcat-solr/db/conf/data-config.xml</str>
	 </lst>
</requestHandler>
然后复制该文件和schema.xml到tomcat-solr\db\conf
4.在tomcat-solr\db\conf下新建data-config.xml文件
<dataConfig>
<dataSource type="JdbcDataSource" driver="oracle.jdbc.driver.OracleDriver" url="jdbc:oracle:thin:@10.8.9.244:1521:orcl" user="RMSUSER" password="RMSUSER"/>
<document name="t_base_grade">
<entity name="t_base_grade" pk="grade_id" query="select * from t_base_grade">
			<field column="grade_id" name="grade_id" />
			<field column="grade_name" name="grade_name" />
             <field column="intro" name="intro" />
             <field column="sort_num" name="sort_num" />
			 <field column="status" name="status" />
			 <field column="creator_id" name="creator_id" />
			 <field column="create_time" name="create_time" />
			 <field column="modifier_id" name="modifier_id" />
			 <field column="modify_time" name="modify_time" />
</entity>
</document>
</dataConfig>
5.在schema.xml添加与数据库对应的字段
<schema>
<fields>
   <!-- 下面两句不能少--> 
   <field name="_version_" type="long" indexed="true" stored="false"/>
   <field name="_root_" type="string" indexed="true" stored="false"/>
   <!--属性stored设为TRUE-->
   <field name="grade_id" type="string" indexed="true" stored="true" required="true" multiValued="false"/>
   <field name="grade_name" type="string" indexed="true" stored="true"/>
   <field name="intro" type="string" indexed="true" stored="true"/>
   <field name="sort_num" type="sint" indexed="true" stored="true"/>
   <field name="status" type="string" indexed="true" stored="true"/>
   <field name="creator_id" type="string" indexed="true" stored="true"/>
   <field name="create_time" type="date" indexed="true" stored="true"/>
   <field name="modifier_id" type="string" indexed="true" stored="true"/>
   <field name="modify_time" type="date" indexed="true" stored="true"/>
</fields>
<uniqueKey>grade_id</uniqueKey> 
</schema>
6.进行数据导入http://localhost:8080/solr/db/dataimport?command=full-import

</2014-7-10>

<2014-7-11>
一、mongodb查询语法
{"dear_id":{"$exists":true}}

二、solr应用（http://blog.csdn.net/IBM_hoojo）

</2014-7-11>

<2014-7-14>
一、阿里巴巴dubbo框架
dubbo是阿里的一个开源soa（service-oriented architecture面向服务的体系结构）框架
Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和Spring框架无缝集成。
Remoting: 网络通信框架，实现了 sync-over-async 和 request-response 消息机制.
RPC: 一个远程过程调用的抽象，支持负载均衡、容灾和集群功能
Registry: 服务目录框架用于服务的注册和服务事件发布和订阅
Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架（告别<span>Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册
其核心部分包含:
1. 远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。
2. 集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。
3. 自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。
Dubbo能做什么？
1.透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 
2.软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。
3. 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。

二、ZooKeeper一种分布式应用的协作服务
是一种分布式的，开源的，应用于分布式应用的协作服务。它提供了一些简单的操作，使得分布式应用可以基于这些接口实现诸如同步、配置维护和分集群或者命名的服务。Zookper很容易编程接入，它使用了一个和文件树结构相似的数据模型。
Zookeeper通过一种和文件系统很像的层级命名空间来让分布式进程互相协同工作。这些命名空间由一系列数据寄存器组成，我们也叫这些数据寄存器为znodes。这些znodes就有点像是文件系统中的文件和文件夹。和文件系统不一样的是，文件系统的文件是存储在存储区上的，而zookeeper的数据是存储在内存上的。同时，这就意味着zookeeper有着高吞吐和低延迟。

Zookeeper实现了高性能，高可靠性，和有序的访问。高性能保证了zookeeper能应用在大型的分布式系统上。高可靠性保证它不会由于单一节点的故障而造成任何问题。有序的访问能保证客户端可以实现较为复杂的同步操作。
zookeeper是Hadoop的子项目，主要功能基于paxos算法对分布式系统的请求进行调度


三、Google的分布式锁机制Chubby


四、进入tomcat管理页面
配置好了以后你在浏览器地址栏输入http://localhost:8080/就可以进入欢迎界面。
这个时候是进不了管理界面的。怎么才能进去呢？首先看看你解压的tomcat下webapps目录下是否有ROOT，manager，host-manager这三个项目，若有就说明Ok。
再去tomcat的conf/Catalina/localhost目录下面看看是否有manager.xml这个文件
<?xml version="1.0" encoding="UTF-8"?>
<Context antiResourceLocking="false" privileged="true" />
然后进入tomcat的conf去修改tomcat-users.xml文件。看上去应该像这样
<?xml version='1.0' encoding='utf-8'?>
<tomcat-users>
  <role rolename="manager"/>
  <role rolename="admin"/>
  <user username="yourname" password="secret” roles="admin,manager"/>
</tomcat-users>


五、利用ant打包项目或打增量包的基本流程
build.xml：
<?xml version="1.0" encoding="utf-8"?>
<project name="edu_cms" default="clean">
	<echo message="-----------CMS SERVER BUILD STARTING  ------------" />
	<echo message="-----------BUILD STARTING INIT ------------" />
	
	<echo>教育云平台 CMS server打包工程开始...</echo>
	<echo>[1] 开始初始化工作....</echo>
	<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- --> 
	<!--                   macros                          -->
	<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- -->
	<property environment="env"/>
	<property name="app.root" value="../../edu_cms" />
	<property name="app.name" value="cms.war" />  
	
	<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- -->
	<!--                   directories                     -->
	<!-- -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- -->
	<echo>[2] 用到的lib....</echo>
	<echo message="-----------[2]BUILD STARTING USE LIB ------------" />
    <property name="lib.dir" value="${app.root}/webapps/WEB-INF/lib"/>
	<property name="lib.other.dir" value="${app.root}/lib"/>

    <echo>[3] build dir output....</echo>
    	<echo>[3] build目录....</echo>
    <property name="build.dir"      value="./output" />
    <property name="build.src"      value="${build.dir}/src" />	
    <property name="build.classes"  value="${build.dir}/classes"/>
    <property name="build.lib"      value="${build.dir}/lib"/>

    <echo>[4] bulid dir release ....</echo>
    	<echo>[4] release目录....</echo>
    <property name="release.dir"      value="${env.RELEASE_HOME}" />系统的tomcat安装目录设置到release.dir属性中
	<property name="release.dbscript"  value="${release.dir}/dbscript" />
	<property name="release.conf"  value="${release.dir}/conf" />
	<property name="release.tools"  value="${release.dir}/tools" />
	<property name="release.releaseNotes"  value="${release.dir}/releaseNotes" />
	
	<echo>[5] (distribution) dir....</echo>
	<echo>[5] (distribution) 目录....</echo>
    <property name="dist.dir"         value="./dist"/>
    <property name="dist.edu_cms.dir"   value="${dist.dir}/edu_cms"/>
    <property name="dist.edu_cms.web.inf"  value="${dist.edu_cms.dir}/WEB-INF"/>
    <property name="dist.edu_cms.web.inf.lib"  value="${dist.edu_cms.web.inf}/lib"/>		
    <property name="dist.edu_cms.web.inf.classes"  value="${dist.edu_cms.web.inf}/classes"/>		

	<echo>[6] classpath</echo>
	<echo>[6] 定义classpath可以通过id重用这组路径</echo>
	<path id="classpath">
		<pathelement location="${build.classes}"/>	
		<pathelement path="${java.home}/lib/tools.jar"/>
	    <fileset dir="${lib.dir}">   
	        <include name="**/*.jar"/>
	    </fileset>   
		<fileset dir="${lib.other.dir}">   
			 <include name="**/*.jar"/>
	    </fileset>   
	</path>
	
	<echo>[7] clear old dir and make new dir,make relealse dir starting</echo>
	<echo>[7] 清除以前目录 同时创建build目录 创建release目录开始</echo>
    <target name="init">   
        <!--创建时间戳-->   
        <tstamp/>   

		<delete dir="${build.dir}"/>
		<delete dir="${release.dir}"/> 
    	<delete dir="${dist.dir}"/> 
      
        <mkdir dir="${build.dir}"/>
		<mkdir dir="${build.src}"/>
		<mkdir dir="${build.classes}"/>
		<mkdir dir="${build.lib}"/>    	
 
        <mkdir dir="${release.dir}"/>
		<mkdir dir="${release.dbscript}"/>
		<mkdir dir="${release.conf}"/>
		<mkdir dir="${release.tools}"/>
		<mkdir dir="${release.releaseNotes}"/>
   
    	<mkdir dir="${dist.dir}"/>   
    	<mkdir dir="${dist.edu_cms.dir}"/>
    	<mkdir dir="${dist.edu_cms.web.inf}"/>
    	<mkdir dir="${dist.edu_cms.web.inf.lib}"/>
    	<mkdir dir="${dist.edu_cms.web.inf.classes}"/>
    </target>   
    <echo>[7] clear old dir and make new dir,make relealse dir ending</echo>
	<echo>[7] 清除以前目录 同时创建build目录 创建release目录结束</echo>
	
    <echo>[8] copy java file starting....</echo>
	<echo>[8] 开始JAVA文件拷贝....</echo>
	<target name="copy" depends="init">
        <copy todir="${build.src}">
			<fileset dir="${app.root}/src">
				<include name="**/*.*" />
				<exclude name="**/*.svn" />
			</fileset>
        </copy>
	</target>  
	<echo>[8] 文件拷贝正常结束</echo>
    <echo>[8] copy java file ending....</echo>
	
	<echo>[9] 编译工作正常开始</echo>
    <target name="compile" depends="copy">   
		<javac srcdir="${build.src}" destdir="${build.classes}" encoding="UTF-8" debug="false" deprecation="off" nowarn="on" extdirs="true" >
		    <classpath refid="classpath"/>
		</javac>
    </target>   
    <echo>[9] 编译工作正常结束</echo>
	
	<echo>[10] 拷贝src目录的配置文件开始</echo>
	<target name="jars" depends="compile">
		<copy todir="${build.classes}">
			<fileset dir="${build.src}">   
				<include name="**/*.*" />
				<exclude name="**/*.java"/> 
			</fileset>   
        </copy>
	</target>
	<echo>[10] 拷贝src目录的配置文件结束</echo>
	
	<echo>[11] 生成war包开始</echo>
	<target name="war" depends="jars">
		
		<copy todir="${dist.edu_cms.dir}">
			<fileset dir="${app.root}/webapps">
				<include name="**/*.*" />
				<exclude name="**/*.svn" />
			</fileset>
        </copy>
		
		<copy todir="${dist.edu_cms.web.inf.lib}">
			<fileset dir="${lib.dir}">
				 <include name="**/*.jar"/>  //includes表示别归档的文件模式。 
    			 <exclude name="**/servlet-api.jar"/>// exchudes表示被排除的文件模式。
			</fileset>
			<fileset dir="${lib.other.dir}">
				<include name="**/*.jar"/>  
			</fileset>
        </copy>	

		<copy todir="${dist.edu_cms.web.inf.classes}">
			<fileset dir="${build.classes}">
				<include name="**/*.*"/> 
			</fileset>
		</copy>
	
		<jar basedir="${dist.edu_cms.dir}" jarfile="${dist.dir}/${app.name}"/>		
	</target>
	<echo>[11] 生成war包结束</echo>
	<echo>${env.RELEASE_HOME}</echo>
	
    <target name="release" depends="war">
    	
		<copy todir="${release.dir}">
			<fileset dir="${dist.dir}">
				<include name="*.war"/>   
			</fileset>
        </copy>
    	
		<copy todir="${release.dbscript}">
			<fileset dir="../dbscript">
				<include name="**/*.*" />
				<exclude name="**/*.svn" />
			</fileset>
        </copy>    	 
        
    	<copy todir="${release.conf}">
			<fileset dir="../conf">
				<include name="**/*.*" />
				<exclude name="**/*.svn" />
			</fileset>
        </copy> 

        <copy todir="${release.tools}">
			<fileset dir="../tools">
        		<include name="**/*.*" />
				<exclude name="**/*.svn" />
			</fileset>
        </copy> 
 
        <copy todir="${release.releaseNotes}">
			<fileset dir="../releaseNotes">
        		<include name="**/*.*" />
				<exclude name="**/*.svn" />
			</fileset>
        </copy> 
    </target>  
	
	<target name="clean" depends="release">	
		<delete dir="${build.dir}"/>
		<delete dir="${dist.dir}"/> 
	</target>
</project>

六、ant配置
在dos窗口中输入命令ant，若出现结果: 
   Buildfile：build.xml does not exist! 
   Build failed 
说明ant安装成功！因为ant默认运行build.xml文件，这个文件需要我们建立。 
一个简单的使用ANT的例子
在 D 盘根目录下新建一个 build.xml 文件，文件的内容如下：
<?xml version="1.0" encoding="GBK"?>
<project name="测试脚本" default="copyfile" basedir="." >
   <target name="copyfile">
      <copy file="d:/a.txt" todir="e:/Temp" overwrite="true" />
   </target>
</project> 
在 D 盘根目录下新建一个 a.txt 文件，内容随便。
进入DOS，依次执行：
  d: 
  ant

七、工程导入war

</2014-7-14>

<2014-7-15>
一、spring bean
<bean id="statisticsCPJobTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean">
		<property name="jobDetail" ref="statisticsCPJob"></property>
		<property name="cronExpression" value="0 0 0 * * ?"></property>
</bean>
附表：
秒（0-59），分（0-59），小时（0-23），日（1-31），月（1-12），周（1-7），年
 "0 0 12 * * ?" 每天中午12点触发
 "0 15 10 ? * *" 每天上午10:15触发
 "0 15 10 * * ?" 每天上午10:15触发
 "0 15 10 * * ? *" 每天上午10:15触发
 "0 15 10 * * ? 2005" 2005年的每天上午10:15触发
 "0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发
 "0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发
 "0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
 "0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发
 "0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发
 "0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发
 "0 15 10 15 * ?" 每月15日上午10:15触发
 "0 15 10 L * ?" 每月最后一日的上午10:15触发
 "0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发
 "0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发
 "0 15 10 ? * 6#3" 每月的第三个星期五上午10:15触发
 
可用值详细分析如下：
 
“*”――字符可以用于所有字段，在“分”字段中设为"*"表示"每一分钟"的含义。
 
“?”――字符可以用在“日”和“周几”字段. 它用来指定 '不明确的值'. 这在你需要指定这两个字段中的某一个值而不是另外一个的时候会被用到。在后面的例子中可以看到其含义。
 
“-”――字符被用来指定一个值的范围，比如在“小时”字段中设为"10-12"表示"10点到12点"。
 
“,”――字符指定数个值。比如在“周几”字段中设为"MON,WED,FRI"表示"the days Monday, Wednesday, and Friday"。
 
“/”――字符用来指定一个值的的增加幅度. 比如在“秒”字段中设置为"0/15"表示"第0, 15, 30, 和 45秒"。而 "5/15"则表示"第5, 20, 35, 和 50". 在'/'前加"*"字符相当于指定从0秒开始. 每个字段都有一系列可以开始或结束的数值。对于“秒”和“分”字段来说，其数值范围为0到59，对于“小时”字段来说其为0到23, 对于“日”字段来说为0到31, 而对于“月”字段来说为1到12。"/"字段仅仅只是帮助你在允许的数值范围内从开始"第n"的值。
 
“L”――字符可用在“日”和“周几”这两个字段。它是"last"的缩写, 但是在这两个字段中有不同的含义。例如,“日”字段中的"L"表示"一个月中的最后一天" ―― 对于一月就是31号对于二月来说就是28号（非闰年）。而在“周几”字段中, 它简单的表示"7" or "SAT"，但是如果在“周几”字段中使用时跟在某个数字之后, 它表示"该月最后一个星期×" ―― 比如"6L"表示"该月最后一个周五"。当使用'L'选项时,指定确定的列表或者范围非常重要，否则你会被结果搞糊涂的。
 
“W”――可用于“日”字段。用来指定历给定日期最近的工作日(周一到周五) 。比如你将“日”字段设为"15W"，意为: "离该月15号最近的工作日"。因此如果15号为周六，触发器会在14号即周五调用。如果15号为周日, 触发器会在16号也就是周一触发。如果15号为周二,那么当天就会触发。然而如果你将“日”字段设为"1W", 而一号又是周六, 触发器会于下周一也就是当月的3号触发,因为它不会越过当月的值的范围边界。'W'字符只能用于“日”字段的值为单独的一天而不是一系列值的时候。
 
“L”和“W”可以组合用于“日”字段表示为'LW'，意为"该月最后一个工作日"。
 
“#”―― 字符可用于“周几”字段。该字符表示“该月第几个周×”，比如"6#3"表示该月第三个周五( 6表示周五而"#3"该月第三个)。再比如: "2#1" = 表示该月第一个周一而 "4#5" = 该月第五个周三。注意如果你指定"#5"该月没有第五个“周×”，该月是不会触发的。
 
“C”―― 字符可用于“日”和“周几”字段，它是"calendar"的缩写。 它表示为基于相关的日历所计算出的值（如果有的话）。如果没有关联的日历, 那它等同于包含全部日历。“日”字段值为"5C"表示"日历中的第一天或者5号以后"，“周几”字段值为"1C"则表示"日历中的第一天或者周日以后"。

二、maven进阶：一个多模块项目 
一个多模块项目通过一个父POM 引用一个或多个子模块来定义。父项目，通过以下配置，将子项目关联。
<modules>
		<module>cms-api</module>
		<module>cms-portal</module>
		<module>cms-service</module>
		<module>cms-common</module>
		<module>cms-job</module>
		<module>cms-manage</module>
		<module>cms-gateway</module>
		<module>cms-ft</module>
</modules>
当然，仅仅在父项目，配置子项目是不能够真正实现关联的，因为，这毕竟需要子项目的同意，故！子项目中需要配置：
<parent>
		<groupId>com.whty</groupId>
		<artifactId>edu-cms</artifactId>
		<version>0.0.1</version>
</parent>

</2014-7-15>
<2014-7-16>
一、zookeeper的监控工具

二、
</2014-7-16>
<2014-7-17>
一、cms-ft
解决带宽问题

二、HTML断点续传控制插件

三、SiteMesh
siteMesh用来装饰网页。使网页具有统一的布局。这对于实际项目有很大的帮助。SiteMesh是基于Java、J2EE和XML的开源框架，依赖于从Servlet 2.3版本里引入的新功能――过滤器(Filters)，它的主要思想是装饰设计模式，把变化的和不变的分离开来，用不变的去修饰各种变化的内容。
siteMesh通过拦截静态活或动态网页的request请求。从而处理网页，给网页加上自定义的装饰。
使用siteMesh会不会影响网页的访问速度呢？siteMesh官网上说是基本不影响，因为siteMesh的处理速度是非常快的。
还可以通过扩展siteMesh来达到用户的需求。


</2014-7-17>
<2014-7-21>
一、@ResponseBody
@RequestBody 将HTTP请求正文转换为适合的HttpMessageConverter对象。 
@ResponseBody 将内容或对象作为 HTTP 响应正文返回，并调用适合HttpMessageConverter的Adapter转换对象，写入输出流。

 @ResponseBody 将内容或对象作为 HTTP 响应正文返回，使用@ResponseBody将会跳过视图处理部分，而是调用适合HttpMessageConverter，将返回值写入输出流。
@RequestMapping(params="method=view")
@ResponseBody
public String view(@RequestParam("id") Long id,
   HttpServletRequest request, 
   HttpServletResponse response){
 ...
 return jsonData;
}
      如上可以直接返回json字符串。如果不配置@ResponseBody，也可以使用response输出数据然后 return null，达到返回json字符串的效果。
      @ResponseBody之后返回字符串中中文可能会出现乱码，因为sping mvc默认是text/plain;charset=ISO-8859-1，要支持中需做如下配置：
<bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter">
 <property name="messageConverters">
  <list>
   <bean class="org.springframework.http.converter.StringHttpMessageConverter">
    <property name="supportedMediaTypes">
     <list>
      <value>text/plain;charset=UTF-8</value>
     </list>
    </property>
   </bean>
  </list>
 </property>
</bean>
 
</2014-7-21>

<2014-7-22>
一、创建一个序列 
create sequence Play_Sequence increment by 1 start with 1 nomaxvalue;


二、mybatis主键获取
 <insert id="insertOne" parameterType="AttachFile">
    	<selectKey keyProperty="fid" resultType="long" order="BEFORE">
    		select SEQ_ATTACH_FILE.NEXTVAL from dual
    	</selectKey>
        insert into T_ATTACH_FILE (
        <trim suffixOverrides=",">
        	<if test="fid != null">
            	FID,
            </if>
		</trim> ) values (
        <trim suffixOverrides=",">
        	<if test="fid != null">
            	#{fid},
            </if>
		</trim>  
        )
 </insert>

三、熟练使用Unix、Linux，可以使用Shell编程

</2014-7-22>

<2014-7-23>
一、打开"C:\WINDOWS\system32\drivers\etc" 目录


二、用document.domain解决Ajax跨子域 
document.domain 用来得到当前网页的域名。
利用document.domain实现跨域：前提条件：这两个域名必须属于同一个基础域名，而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域
因为浏览器的安全策略，浏览器不允许不同域(比如：dancewithnet.com和 lab.dancewithnet.com)、不同协议(比如:http://dancewithnet.com和https: //dancewithnet.com)、不同端口(比如:http:dancewithnet.com和http: //dancewithnet.com:8080)下的页面通过XMLHTTPRequest相互访问，这个问题同样影响着不同页面的 Javascript的相互调用和控制，但是当主域、协议、端口相同时，通过设置页面的document.domain主域，Javascript可以在不同的子域名间访问控制，比如通过设置 document.domain=’dancewithnet.com’，http://dancewithnet.com和http: //lab.dancewithnet.com页面可互访，这个特性也提供了此情况下不同子域名下的XMLHTTPRequest相互访问的解决方案。
 
对于主域、协议、端口相同时的Ajax跨域问题，很早就有设置document.domain来解决的说法，但一直没有看到具体的成功应用，这几天尝试了一下，其原理就是，利用一个隐藏的iframe引入所跨另一子域的页面作为代理，通过Javascript来控制iframe引入的另一子域的 XMLHTTPRequest来进行数据获取。

三、编码
String pathLocal = request.getParameter("pathLocal");
pathLocal = pathLocal.replaceAll("\\+", "%20");
// 客户端使用的是encodeURIComponent编码
pathLocal = URLDecoder.decode(pathLocal, "UTF-8");// utf-8解码


</2014-7-23>

<2014-7-24>
一、Spring MVC
<!-- 对模型视图名称的解析，即在模型视图名称添加前后缀 -->      
    <bean id="ViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">  
        <property name="prefix" value="/"></property> <!-- 视图文件的前缀 -->   
        <property name="suffix" value=".jsp"></property> <!-- 视图文件的后缀名 -->   
        <!-- view是用什么显示，这里是jsp，还可以用velocity之类的 -->  
        <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"></property>    
    </bean>  

来让DispacherServlet进行加载默认的viewResolver，如果没有设置viewResolver，spring使用InternalResourceViewResolver进行解析。

Spring实现ViewResolver的非抽象类且我们经常使用的viewResolver有以下四种：

1.InternalResourceViewResolver 将逻辑视图名字解析为一个路径 
2.BeanNameViewResolver 将逻辑视图名字解析为bean的Name属性，从而根据name属性，找定义View的bean 
3.ResourceBundleResolver 和BeanNameViewResolver一样，只不过定义的view-bean都在一个properties文件中，用这个类进行加载这个properties文件 
4.XmlViewResolver 和ResourceBundleResolver一样，只不过定义的view-bean在一个xml文件中，用这个类来加载xml文件 

使用多视图解析器：
我们不想只使用一种视图解析器的话，可以在[spring-dispatcher-name]-servlet.xml定义多个viewResolver：
<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"> <property name="prefix" value="/jsp/"/> 
<property name="suffix" value=".jsp"/>
</bean> 
<bean id=”beanNameViewResolver” class=”...BeanNameViewResolver”> 
<property name="order" value="1"></property>
</bean> 
<bean id=”beanNameViewResolver” class=”...XmlViewResolver”>
<property name="order" value="0"></property> 
</bean>
DispatcherServlet会加载所有的viewResolver到一个list中，并按照优先级进行解析。注意order中的值越小，优先级越高。而id为viewResolver的viewResolver的优先级是最低的。

二、Spring组件扫描
在xml配置了这个标签后，spring可以自动去扫描base-pack下面或者子包下面的java文件，如果扫描到有@Component @Controller@Service等这些注解的类，则把这些类注册为bean
注意：如果配置了<context:component-scan>那么<context:annotation-config/>标签就可以不用再xml中配置了，因为前者包含了后者。另外<context:annotation-config/>还提供了两个子标签
1.        <context:include-filter>
2.       <context:exclude-filter>
在说明这两个子标签前，先说一下<context:component-scan>有一个use-default-filters属性，改属性默认为true,这就意味着会扫描指定包下的全部的标有@Component的类，并注册成bean.也就是@Component的子注解@Service,@Reposity等。所以如果仅仅是在配置文件中这么写
<context:component-scan base-package="tv.huan.weisp.web"/>
 Use-default-filter此时为true那么会对base-package包或者子包下的所有的进行java类进行扫描,并把匹配的java类注册成bean。
 可以发现这种扫描的粒度有点太大，如果你只想扫描指定包下面的Controller，该怎么办？此时子标签<context:incluce-filter>就起到了勇武之地。如下所示
<context:component-scan base-package="tv.huan.weisp.web .controller">  
<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>   
</context:component-scan>  
这样就会只扫描base-package指定下的有@Controller下的java类，并注册成bean
但是因为use-dafault-filter在上面并没有指定，默认就为true，所以当把上面的配置改成如下所示的时候，就会产生与你期望相悖的结果（注意base-package包值得变化）
<context:component-scan base-package="tv.huan.weisp.web ">  
<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>   
</context:component-scan>  
此时，spring不仅扫描了@Controller，还扫描了指定包所在的子包service包下注解@Service的java类
此时指定的include-filter没有起到作用，只要把use-default-filter设置成false就可以了。这样就可以避免在base-packeage配置多个包名这种不是很优雅的方法来解决这个问题了。
另外在我参与的项目中可以发现在base-package指定的包中有的子包是不含有注解了，所以不用扫描，此时可以指定<context:exclude-filter>来进行过滤，说明此包不需要被扫描。综合以上说明
Use-dafault-filters=”false”的情况下：<context:exclude-filter>指定的不扫描，<context:include-filter>指定的扫描


</2014-7-24>
<2014-7-25>
一、filezilla
FileZilla是一个免费开源的FTP客户端软件，分为客户端版本和服务器版本，具备所有的FTP软件功能。可控性、有条理的界面和管理多站点的简化方式使得Filezilla客户端版成为一个方便高效的FTP客户端工具，而FileZilla Server则是一个小巧并且可靠的支持FTP&SFTP的FTP服务器软件。            
　　FileZilla是一种快速、可信赖的FTP客户端以及服务器端开放源代码程式，具有多种特色、直觉的接口。可控性、有条理的界面和管理多站点的简化方式使得Filezilla客户端版成为一个方便高效的FTP客户端工具，而FileZilla Server则是一个小巧并且可靠的支持FTP&SFTP的FTP服务器软件。FileZilla在2003年11月获选为当月最佳推荐专案。

二、SecureCRT中常用linux命令

查看内存状态命令： free  
查看磁盘空间使用情况：  df -am 
linux后台执行程序： nohup java -jar ****.jar &  
目前使用CPU,MEM的状况 ps -uxwww   
修改文件编码方式：  iconv -f gbk -t utf8 index.html > index1.html 把gbk编码的index.html文件转成index1.html
查找目录：  查找名字为conf的目录  #find /目录-type d -name conf   second  ****************************************************************  
常用命令：  
一、ls只列出文件名（相当于dir，dir也可以使用） 
-A:列出所有文件，包含隐藏文件。  
-l：列表形式，包含文件的绝大部分属性。 
-R：递归显示。 
--help：此命令的帮助。 
二、cd 改变目录  
cd /:进入根目录  
cd ：回到自己的目录（用户不同则目录也不同，root为/root，xxt为/home/xxt 
cd ..：回到上级目录  
pwd：显示当前所在的目录 
三.less 文件名：查看文件内容。 
四.q 退出打开的文件。 
五.上传文件： rz选择要传送的文件，确定。 
六.下载文件： sz指定文件名,enter敲，即下载到了secureCRT/download目录下。
七：删除文件： rm删除文件 ，rmdir删除空目录。   
八.显示最近输入的20条命令：history 20    
九.获得帮助命令 --help查看命令下详细参数：  如：rz --help   ，sz --help  。 十.cd 进入某个文件夹的命令： 
mkdir+ 文件夹名创建某个文件夹的命令 
sz+文件名从服务器端向本机发送文件的命令
rz从本机向服务器端传送文件的命令  
ll列出当前目录下的所有文件,包括每个文件的详细信息 dir对当前文件夹 vi 打开当前文件  
十一.在编辑某个文件的时候：
a 切换到编辑模式 
ctrl+c退出编辑模式 
dd删除整行 
:q 退出当前文件  
:w 写入并保存当前文件 
-f 强行xx的参数。。。   
其它命令：  1.ps -ef  //查看server的进程,以列表形式显示的server进程。 
 ps显示当前在系统运行的进程 
 /usr/bin/ps [选项] 
 -e 显示每个现在运行的进程 
 -f 生成一个完全的列表  
 实际操作：  -------------------------------------- 
 1 SSH客户端连接到10.5.1.55系统（参见《启动远程客户端说明SecureCRT.doc》） 
 $ cd /home/bea2/user_projects/csdomain/bin 
 2 查看weblogic92服务进程    略  
 3 执行如下命令杀掉进程  $ kill -9 491796（根据2操做查找到得系统进程号）  说明：执行后再执行$ ps -eaf | grep weblogic命令将不会看到该进程号的weblogic进程 
 4 启动服务 $ ./quickRun.sh  ------------------------------------------------------------------- 
 2.ant -buildfile CMS_MainTrunk.xml  //build 包 
 3.vi test.txt  //浏览文件内容 i {insert写输入} 
 esc  退出insert  
 :wq! write 保存并退出vi模式   
 :q!  不保存退出vi模式  
 4.我一般习惯用ps Cef命令，这样看到以列表形式显示的server进程；用命令pstree来查看server的进程，这样看到以树的形式显示的server进程。 Pstree命令的优点在于可以立即找出某进程的父进程。您可能会需要使用 -p 选项显示每个进程的 PID，以及 -u 选项来显示启动该进程的用户名。  一般来说，这一树结构比较长，您就需要这么执行pstree Cup | less 这将让您纵览整个进程树结构。 
 5.secureCRT中乱码解决： Options->SessionOptions->Appearance->font把 default改成UTF-8，就可以显示中文字体了。    
 6.hostname：查hostname 
 7.ifconfig 查询主机IP  
 8.在S-CRT下用ctrl+c和ctrl+v：  Options---Global Options---Edit default Settings进去后点 Terminal---Emulation然后点Mapped Keys，点中低部的，use windows copy and paste key，点确认。   
 9.进入vi的命令：   vi filename :打开或新建文件，并将光标置于第一行首  
 vi +n filename ：打开文件，并将光标置于第n行首 
 vi + filename ：打开文件，并将光标置于最后一行首  
 vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处 
 10.移动光标类命令： }：光标移至段落开头  {：光标移至段落结尾  nG：光标移至第n行首  n+：光标下移n行  n-：光标上移n行   n$：光标移至第n行尾  H ：光标移至屏幕顶行  M ：光标移至屏幕中间行  L ：光标移至屏幕最后行   0：（注意是数字零）光标移至当前行首  $：光标移至当前行尾  
 11.屏幕翻滚类命令：  Ctrl+u：向文件首翻半屏  Ctrl+d：向文件尾翻半屏   Ctrl+f：向文件尾翻一屏  //好像是 r Ctrl＋b；向文件首翻一屏    
 12.搜索命令：   
 /pattern：从光标开始处向文件尾搜索pattern  
 ?pattern：从光标开始处向文件首搜索pattern  
n：在同一方向重复上一次搜索命令  
N：在反方向上重复上一次搜索命令  
postgres使用： 
1.进入sql运行环境。  [test@test bin]$ ./psql -n dbname -U usrname stay81=# select count(*) from table1;  count  -------   5986 (1 row)  
2. 退出，使用结束后退出，不然连接一直被挂起。 stay81=# \q  
3.postgres 数据导出。  [postgres@test bin]$ ./pg_dump -U postgres -t testTable -d testDB>testTable.dump  或[postgres@test bin]$ ./pg_dump -U postgres -d testDB -t testTable -F c -v >testTable.dump 
4. postgres数据导入。  [postgres@test bin]$ ./psql -U postgres -d testDB<testTable.dump 或[postgres@test bin]$ ./pg_restore -U postgres -d testDB<testTable.dump 
5.一台主机上将数据库目录转储到另一台主机上。  pg_dump -h host1 -p 5432 dbname | psql -h host2 -p post1 dbname 或./pg_dump -U postgres -d testDB1 -t testTable| ./psql -U postgres -d testDB2  -U 为用户名，-d 为DB名，-t 为表名称，如果整个数据库导出，不需此项。 
6.php执行。  [test@test bin]$ /usr/bin/php -q ./batchstart.php 



</2014-7-25>
一、问题:如何导入导出大数据量(1000万条)的表(如t_employee)？
步骤：
1、从数据库1中导出数据
2、使用delete删除数据2中相同表的所有数据。
3、导入。

思考：以上步骤对吗？
分析：错误有2。
1、不应该使用delete删除大量数据。
2、在数据导入时，数据库系统将会同时维护索引。所以效率会很低。

正确的做法是：
1、从数据库1中导出
2、删除数据库2中对应表中的所有索引对象
3、使用truncate命令清除该表的所有数据
4、导入(此时数据库不会再维护索引，效率最高)
5、重建相关索引(使用脚本)

注意：此项操作带有一定的技巧，可作为工作经验在面试时使用。

二、SecureCRT命令
输入top命令，可以有效解决连接中断。
TMOUT=0,可以有效解决连接中断。

三、solr类使用

SolrServer solrServer = new HttpSolrServer("http://www.wuhaneduyun.cn:10000/solr/product/");
ModifiableSolrParams params = new ModifiableSolrParams();
// 查询关键词，*:*代表所有属性、所有值，即所有index
params.set("q", "*:*");
params.set("start", 0);
params.set("rows", 1);//设置查询几行数据
List<ProductSolr> prodReslist = null;
QueryResponse response = solrServer.query(params);
int allNum = (int)response.getResults().getNumFound();
prodReslist = response.getBeans(ProductSolr.class);

四、Mongodb类使用
Mongo mongo = new Mongo("127.0.20.22",30000);    
DB db2 = mongo.getDB("tycms");//数据库
DBCollection coll2 = db2.getCollection("cms_Content");//表
DBObject query = new BasicDBObject();
query.put("contentId", contentId);
DBCursor cursor =coll2.find(query);
if(cursor.hasNext()){
	DBObject obj = cursor.next();
	return obj.get("dear_id").toString();
}


五、Spring ClassPathXmlApplicationContext和FileSystemXmlApplicationContext
ClassPathXmlApplicationContext 这个类,默认获取的是WEB-INF/classes/下的路径,也就是在myeclipse的src下的路径,所以用这个是获取不到WEB-INF下的配置文件的...
 下面是几个用法,引src下的一个文件,有以下几种方式 
Java代码  
1.BeanFactory ac = new ClassPathXmlApplicationContext("applicationContext.xml"); 
2.BeanFactory ac = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");  
3.BeanFactory ac = new ClassPathXmlApplicationContext("classpath:/applicationContext.xml");  
4.ac.getBean("beanID");  
classpath:和classpath*:的区别: 
classpath:   只能加载一个配置文件,如果配置了多个,则只加载第一个 
classpath*:  可以加载多个配置文件,如果有多个配置文件,就用这个 
引src下的多个文件,有以下几种方式 
Java代码  
1.BeanFactory ac = new ClassPathXmlApplicationContext(new String[]{"applicationContext.xml","applicationContext-test.xml"});  
2.BeanFactory ac = new ClassPathXmlApplicationContext("classpath*:/applicationContext*.xml");  
3.BeanFactory ac = new ClassPathXmlApplicationContext("classpath*:src/folder/applicationContext*.xml"); 

再说:FileSystemXmlApplicationContext 
这个类,默认获取的是项目路径,就是项目名的这级.但是我测试,在myeclipse下,执行main方法,获取配置文件,路径用WebRoot/WEB-INF/是没问题的,但是发布到tomcat下,就怎么配都不成功了,无奈,只能把配置文件全部移到src下了,因为担心发布到linux上后,又出现路径问题
下面是几个用法,引WEB-INF下的一个文件,有以下几种方式 
Java代码  
1.BeanFactory factory = new FileSystemXmlApplicationContext("WebRoot/WEB-INF/applicationContext.xml");  
2.BeanFactory factory = new FileSystemXmlApplicationContext("file:D:/workspace/testproject/WebRoot/WEB-INF/applicationContext.xml");  
其中,FileSystemXmlApplicationContext的起始路径是项目路径,所以可以直接这样写WebRoot/WEB-INF 
如果前边加了file:则说明后边的路径就要写全路径了,就是绝对路径 
下面是几个用法,引WEB-INF/classes下的一个文件,有以下几种方式 
Java代码  
1.BeanFactory factory = new FileSystemXmlApplicationContext("classpath:applicationContext.xml");  
这其实跟ClassPathXmlApplicationContext是一样的,多个就加通配符 
下面是几个用法,引WEB-INF下的多个文件,有以下几种方式 
Java代码  
1.BeanFactory factory = new FileSystemXmlApplicationContext(new String[]{"WebRoot/WEB-INF/applicationContext.xml","WebRoot/WEB-INF/applicationContext-test.xml"});  
2.BeanFactory factory = new FileSystemXmlApplicationContext("WebRoot/WEB-INF/applicationContext*.xml");  
3.BeanFactory factory = new FileSystemXmlApplicationContext("file:D:/workspace/testproject/WebRoot/WEB-INF/applicationContext*.xml");  
引WEB-INF/classes下的多个文件,也是一样的 
Java代码  
1.BeanFactory factory = new FileSystemXmlApplicationContext(new String[]{"classpath:applicationContext.xml","classpath:applicationContext*.xml"});  
2.BeanFactory factory = new FileSystemXmlApplicationContext("classpath*:applicationContext*.xml");  

六、Spring集成Quartz定时任务框架介绍和Cron表达式详解 
在JavaEE系统中，我们会经常用到定时任务，比如每天凌晨生成前天报表，每一小时生成汇总数据等等。
我们可以使用java.util.Timer结合java.util.TimerTask来完成这项工作，但时调度控制非常不方便，并且我们需要大量的代码。
使用Quartz框架无疑是非常好的选择，并且与Spring可以非常方便的集成，下面介绍它们集成方法和Cron表达式的详细介绍。
增加所依赖的JAR包：
1、增加Spring的Maven依赖 
<dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>3.0.5.RELEASE</version></dependency> 
2、增加Quartz的Maven依赖 
<dependency> <groupId>org.quartz-scheduler</groupId> <artifactId>quartz</artifactId> <version>1.8.4</version></dependency>
增加定时业务逻辑类 ：
public class ExpireJobTask {    /** Logger */    private static final Logger logger = LoggerFactory.getLogger(ExpireJobTask.class);     /**     * 业务逻辑处理     */    public void doBiz() {  // 执行业务逻辑  // ........    }} 

ExpireJobTask业务逻辑类与一般普通的类没有任务区别，它定义的doBiz方法即为调度业务方法。 
增加Spring配置：
1、增加一个线程池 
<!-- 线程执行器配置，用于任务注册 -->
<bean id="executor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"> <property name="corePoolSize" value="10" /> 
<property name="maxPoolSize" value="100" /> 
<property name="queueCapacity" value="500" />
</bean> 

2、定义业务逻辑处理类 
<!-- 业务对象 --><bean id="bizObject" class="com.aboy.potak.common.toolkit.scheduling.ExpireJobTask" /> 
3、增加调度业务逻辑 
<!-- 调度业务 -->
<bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"> <property name="targetObject" ref="bizObject" /> 
<property name="targetMethod" value="doBiz" /></bean> 
上面的配置中，我们以bizObject.doBiz方法为将要调度的业务执行逻辑。
4、增加调度触发器 
<bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean">
<property name="jobDetail" ref="jobDetail" />
<property name="cronExpression" value="10 0/1 * * * ?" /></bean> 
Cron表达式“10 */1 * * * ?”意为：从10秒开始，每1分钟执行一次。 
<bean id="taskTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerBean">
<property name="jobDetail" ref="jobDetail" />
<property name="startDelay" value="10000" />
<property name="repeatInterval" value="60000" /></bean> 
该调度表示，延迟10秒启动，然后每隔1分钟执行一次。
5、增加调度 
<!-- 设置调度 --><bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
<property name="triggers">  
 <list>  
   <ref bean="cronTrigger" /> 
 </list> 
</property>
<property name="taskExecutor" ref="executor" />
</bean> 
triggers属性中，我们可以增加多个触发器。 
到此，Spring已经与Quartz完美的结合了，我们接下来的工作就是启动系统，开始调度了。

七、Cron表达式的详细用法
字段 允许值 允许的特殊字符 
秒 0-59 , - * / 
分 0-59 , - * / 
小时 0-23 , - * / 
日期 1-31 , - * ? / L W C 
月份 1-12 或者 JAN-DEC , - * / 
星期 1-7 或者 SUN-SAT , - * ? / L C # 
年（可选） 留空, 1970-2099 , - * / 

例子：
0/5 * * * * ? ： 每5秒执行一次
 
“*”字符被用来指定所有的值。如："*"在分钟的字段域里表示“每分钟”。 
“?”字符只在日期域和星期域中使用。它被用来指定“非明确的值”。当你需要通过在这两个域中的一个来指定一些东西的时候，它是有用的。看下面的例子你就会明白。 
月份中的日期和星期中的日期这两个元素时互斥的一起应该通过设置一个问号来表明不想设置那个字段。
 
“-”字符被用来指定一个范围。如：“10-12”在小时域意味着“10点、11点、12点”。
 
“,”字符被用来指定另外的值。如：“MON,WED,FRI”在星期域里表示”星期一、星期三、星期五”。
 
“/”字符用于指定增量。如：“0/15”在秒域意思是每分钟的0，15，30和45秒。“5/15”在分钟域表示每小时的5，20，35和50。符号“*”在“/”前面（如：*/10）等价于0在“/”前面（如：0/10）。记住一条本质：表达式的每个数值域都是一个有最大值和最小值的集合，如：秒域和分钟域的集合是0-59，日期域是1-31，月份域是1-12。字符“/”可以帮助你在每个字符域中取相应的数值。如：“7/6”在月份域的时候只有当7月的时候才会触发，并不是表示每个6月。
 
L是‘last’的省略写法可以表示day-of-month和day-of-week域，但在两个字段中的意思不同，例如day-of-month域中表示一个月的最后一天。如果在day-of-week域表示‘7’或者‘SAT’，如果在day-of-week域中前面加上数字，它表示一个月的最后几天，例如‘6L’就表示一个月的最后一个星期五。
 
字符“W”只允许日期域出现。这个字符用于指定日期的最近工作日。例如：如果你在日期域中写 “15W”，表示：这个月15号最近的工作日。所以，如果15号是周六，则任务会在14号触发。如果15好是周日，则任务会在周一也就是16号触发。如果是在日期域填写“1W”即使1号是周六，那么任务也只会在下周一，也就是3号触发，“W”字符指定的最近工作日是不能够跨月份的。字符“W”只能配合一个单独的数值使用，不能够是一个数字段，如：1-15W是错误的。
 
“L”和“W”可以在日期域中联合使用，LW表示这个月最后一周的工作日。
 
字符“#”只允许在星期域中出现。这个字符用于指定本月的某某天。例如：“6#3”表示本月第三周的星期五（6表示星期五，3表示第三周）。“2#1”表示本月第一周的星期一。“4#5”表示第五周的星期三。
 
字符“C”允许在日期域和星期域出现。这个字符依靠一个指定的“日历”。也就是说这个表达式的值依赖于相关的“日历”的计算结果，如果没有“日历”关联，则等价于所有包含的“日历”。如：日期域是“5C”表示关联“日历”中第一天，或者这个月开始的第一天的后5天。星期域是“1C”表示关联“日历”中第一天，或者星期的第一天的后1天，也就是周日的后一天（周一）。
 
表达式举例
"0 0 12 * * ?" 每天中午12点触发
"0 15 10 ? * *" 每天上午10:15触发
"0 15 10 * * ?" 每天上午10:15触发
"0 15 10 * * ? *" 每天上午10:15触发
"0 15 10 * * ? 2005" 2005年的每天上午10:15触发
"0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发
"0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发
"0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
"0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发
"0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发
"0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发
"0 15 10 15 * ?" 每月15日上午10:15触发
"0 15 10 L * ?" 每月最后一日的上午10:15触发
"0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发 
"0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发
"0 15 10 ? * 6#3" 每月的第三个星期五上午10:15触发

八、Maven
打包输出 ：
Assembly是一个关于打包输出的插件, 比如这样配置: 

Xml代码  
<artifactId>maven-assembly-plugin</artifactId>  
        <configuration>  
          <descriptorRefs>  
            <descriptorRef>jar-with-dependencies</descriptorRef>  
          </descriptorRefs>  
        </configuration>  
</plugin>  
运行命令 
mvn assembly:assembly 
生成xxxx-1.0-jar-with-dependencies.jar的打包文件, 里面将包含所有的依赖文件 

生成项目：
mvn archetype:create 
用来生成项目, artifactId和groupId用来指定目标, archetypeArtifactId通过制定类型, 比如 maven-archetype-webapp用该创建一个web项目
在maven中使用jetty容器, 我们需要这样配置一个插件: 

Xml代码  
<plugin>  
        <groupId>org.mortbay.jetty</groupId>  
        <artifactId>maven-jetty-plugin</artifactId>  
</plugin>  
 
mvn jetty:run 
用来运行jetty服务器 

build配置和dependencies都会被所有的子模块继承 

maven assembly 打包zip,gz等格式文件 
01.<plugin>  
02.                   <artifactId>maven-assembly-plugin</artifactId>  
03.                   <configuration>  
04.                       <!-- not append assembly id in release file name -->  
05.                       <appendAssemblyId>false</appendAssemblyId>  
06.                       <descriptors>  
07.                           <descriptor>src/main/package.xml</descriptor>  
08.                       </descriptors>  
09.                   </configuration>  
10.                   <executions>  
11.                       <execution>  
12.                           <id>make-assembly</id>  
13.                           <phase>package</phase>  
14.                           <goals>  
15.                               <goal>single</goal>  
16.                           </goals>  
17.                       </execution>  
18.                   </executions>  
19.               </plugin> 

01.<assembly xmlns="http://maven.apache.org/POM/4.0.0"  
02.          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
03.          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/assembly-1.0.0.xsd">  
04.    <id>full</id>  
05.    <formats>  
06.        <format>zip</format> <!--打包文件格式-->  
07.    </formats>  
08.    <includeBaseDirectory>true</includeBaseDirectory>  
09.    <fileSets>  
10.        <fileSet>  
11.            <outputDirectory>/</outputDirectory>  
12.            <directory>src/main</directory>  
13.            <includes>  
14.                <include>**/*</include>  
15.            </includes>  
16.            <excludes>  
17.                <exclude>WEB-INF/lib/*</exclude>  
18.            </excludes>  
19.        </fileSet>  
20.    </fileSets>  
21.</assembly> 

然后点击package 即可

format 是打包的格式
fileset -> directory 是打包src/main位置下的源码
execludes包含web-inf/lib/*下的包

*/


九、Jetty容器


十、画图工具
文中的图(大部分类图和时序图)应该主要是eclipse的UML插件(VE)画的，还有用word/powerpoint画的，以及 Xmind等工具画的 :)

十一、shell编程
#! /bin/sh 是指此脚本使用/bin/sh来解释执行，#!是特殊的表示符，其后面跟的是解释此脚本的shell的路径。如果脚本中没有声明，则脚本将在用户默认的shell中执行。用户默认的shell环境是在/etc/passwd中定义：比如passwd文件第一行中 root:x:0:0:root:/root:/bin/bash，最后的/bin/bash说明root用户的默认shell是/bin/bash。虽然#! /bin/sh 可有可无，所以建议就把"#!/bin/sh"当成C 语言的main函数一样，写shell必须有，以使shell程序更严密。


十二、@echo off&setlocal enabledelayedexpansion ，&setlocal enabledelayedexpansion 是什么意思？

set是设置的意思，local是本地的意思，enable是能够的意思，delayed是延迟的意思，expansion是扩展的意思，合起来，就是：让变量成为局部变量，并延迟它的扩展行为 举个简单的例子来说明一下@echo offset num=0&&echo %num%pause本意是想对变量num赋值之后，再把这个值显示出来，结果，显示出来的并不是0，而是显示：ECHO 处于关闭状态。 之所以会出错，是因为“变量延迟”这个家伙在作怪。然后，我们开启变量延迟看一看@echo offsetlocal enabledelayedexpansionset num=0&&echo !num!pause这样就可以显示出结果“0”了。明白了不？ 说得直白一点，所谓的“变量扩展”，实际上就是很简单的这么一件事情：用具体的值去替换被引用的变量及紧贴在它左右的那对百分号。 语言组织能力实在不怎么样，这个语句在批处理中算的上是中高级的类型了，如果你想要详细了解的话，还需要百度“变量延迟”来找一些相应的资料进行学习，在这里我实在不能描述太多，简简单单的一个例子也说明不了问题，因为实际上变量延迟的用法在复合语句中有很多种应用方式，所以建议你通过搜索引擎去找一些相关资料。最后，祝你能早日学成，哈哈……希望我的回答能帮助到你！

<2014-7-26>
<2014-7-29>
一、shell命令
rpm命令 功能类似于Windows里面的“添加/删除程序”，但是功能又比“添加/删除程序”强很多，它就是Red Hat Package Manager(简称RPM)。此工具包最先是由Red Hat公司推出的，后来被其他Linux开发商所借用。由于它为Linux使用者省去了很多时间，所以被广泛应用于在Linux下安装、删除软件。ivh都是rpm命令的参数，可以从rpm --help里找到说明。 意思是显示安装进度和详细信息

ps -ef | grep httpd | grep -v grep
防止列表出grep的进程号。 
用ps -ef | grep httpd 查看进程时，有时会将此“查看进程”也列出来，这当然不是我们希望看到的，而加上grep -v grep 可以防止这种情况。 

awk '{print $2}' 命令：
$2：表示第二个字段
print $2 ： 打印第二个字段
awk '{print $2}'  $fileName :   一行一行的读取指定的文件， 以空格作为分隔符，打印第二个字段比如有这样一个文件
a1  b1  c1  d1
a2  b2  c2  d2
执行的结果是,输出
b1
b2

二、Linq

三、VPN
虚拟专用网(VPN)被定义为通过一个公用网络(通常是因特网)建立一个临时的、安全的连接，是一条穿过混乱的公用网络的安全、稳定的隧道。虚拟专用网是对企业内部网的扩展。虚拟专用网可以帮助远程用户、公司分支机构、商业伙伴及供应商同公司的内部网建立可信的安全连接，并保证数据的安全传输。通过将数据流转移到低成本的压网络上，一个企业的虚拟专用网解决方案将大幅度地减少用户花费在城域网和远程网络连接上的费用。同时，这将简化网络的设计和管理，加速连接新的用户和网站。另外，虚拟专用网还可以保护现有的网络投资。随着用户的商业服务不断发展，企业的虚拟专用网解决方案可以使用户将精力集中到自己的生意上，而不是网络上。虚拟专用网可用于不断增长的移动用户的全球因特网接入，以实现安全连接；可用于实现企业网站之间安全通信的虚拟专用线路，用于经济有效地连接到商业伙伴和用户的安全外联网虚拟专用网。

网一VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。在传统的企业网络配置中，要进行远程访问，传统的方法是租用DDN（数字数据网）专线或帧中继，这样的通讯方案必然导致高昂的网络通讯和维护费用。对于移动用户（移动办公人员）与远端个人用户而言，一般会通过拨号线路（Internet）进入企业的局域网，但这样必然带来安全上的隐患。
让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。

四、分页sql语句
<mapper namespace="CommonMapper">
	<!-- oracle分页查询 -->
	<sql id="pageStart">
		<![CDATA[
			select * from (select rownum as rnum, t.* from (
		]]>
	</sql>
	<sql id="pageEnd">
		<![CDATA[
			) t where rownum <= #{curPage}*#{numPerPage}) where rnum > (#{curPage}-1)*#{numPerPage}
		]]>
	</sql>
</mapper>
例子：
select * from (select rownum as rnum, t.* from(select * from t_attach_file) t where rownum <=19) where rnum >4;

五、函数索引
索引是关系数据库中用于存放每一条记录的一种对象，主要目的是加快数据的读取速度和完整性检查。建立索引是一项技术性要求高的工作。一般在数据库设计阶段的与数据库结构一道考虑。应用系统的性能直接与索引的合理直接有关。下面给出建立索引的方法和要点。
§3.5.1 建立索引
1. CREATE INDEX命令语法:

CREATE INDEX
CREATE [unique] INDEX [user.]index
ON [user.]table (column [ASC | DESC] [,column
[ASC | DESC] ] ... )
[CLUSTER [scheam.]cluster]
[INITRANS n]
[MAXTRANS n]
[PCTFREE n]
[STORAGE storage]
[TABLESPACE tablespace]
[NO SORT]
Advanced
其中：
   schema ORACLE模式，缺省即为当前帐户
   index 索引名
   table 创建索引的基表名
   column 基表中的列名，一个索引最多有16列，long列、long raw
              列不能建索引列
   DESC、ASC 缺省为ASC即升序排序
   CLUSTER 指定一个聚簇（Hash cluster不能建索引）
   INITRANS、MAXTRANS 指定初始和最大事务入口数
   Tablespace 表空间名
   STORAGE 存储参数，同create table 中的storage.
   PCTFREE 索引数据块空闲空间的百分比(不能指定pctused)
   NOSORT 不（能）排序（存储时就已按升序，所以指出不再排序）
 
建立索引的目的是：
l 提高对表的查询速度；
l 对表有关列的取值进行检查。
 
但是，对表进行insert,update,delete处理时，由于要表的存放位置记录到索引项中而会降低一些速度。
注意：一个基表不能建太多的索引；
      空值不能被索引
      只有唯一索引才真正提高速度,一般的索引只能提高30%左右。
 
   Create index ename_in on emp (ename,sal);


六、Oracle序列使用：建立、删除
在开始讲解Oracle序列使用方法之前，先加一点关于Oracle client sqlplus的使用，就是如果执行多行语句的话一定要加“/”才能表示结束，并执行！本篇文章的主题是通过创建Oracle序列和触发器实现表的主键自增。 

1.首先创建序列，Oracle序列的语法格式为：
CREATE SEQUENCE 序列名
[INCREMENT BY n]
[START WITH n]
[{MAXVALUE/ MINVALUE n|NOMAXVALUE}]
[{CYCLE|NOCYCLE}]
[{CACHE n|NOCACHE}]; 

1)INCREMENT BY用于定义序列的步长，如果省略，则默认为1，如果出现负值，则代表Oracle序列的值是按照此步长递减的。 

2)START WITH 定义序列的初始值(即产生的第一个值)，默认为1。 

3)MAXVALUE 定义序列生成器能产生的最大值。选项NOMAXVALUE是默认选项，代表没有最大值定义，这时对于递增Oracle序列，系统能够产生的最大值是10的27次方;对于递减序列，最大值是-1。 

4)MINVALUE定义序列生成器能产生的最小值。选项NOMAXVALUE是默认选项，代表没有最小值定义，这时对于递减序列，系统能够产生的最小值是?10的26次方;对于递增序列，最小值是1。 

5)CYCLE和NOCYCLE 表示当序列生成器的值达到限制值后是否循环。CYCLE代表循环，NOCYCLE代表不循环。如果循环，则当递增序列达到最大值时，循环到最小值;对于递减序列达到最小值时，循环到最大值。如果不循环，达到限制值后，继续产生新值就会发生错误。 

6)CACHE(缓冲)定义存放序列的内存块的大小，默认为20。NOCACHE表示不对序列进行内存缓冲。对序列进行内存缓冲，可以改善序列的性能。 

2.删除Oracle序列的语法是DROP SEQUENCE 序列名; 

假设有表TEST，其主键为TEST_ID
1)建立递增序列SEQ_TEST:
create sequence SEQ_TEST
increment by 1
start with 1
minvalue 1 nomaxvalue
nocylce 

2)建立触发器，当有数据插入表TEST时，使用Oracle序列为其去的递增的主键值
create trigger TRG_TEST before insert on TEST
for each row
begin
select SEQ_TEST.nextval into :new.TEST_ID from dual;
end; 

至此，创建完成！ 
当然也可以不使用触发器，而是在插入时在sql语句中调用序列，例如
insert into TEST values(SEQ_TEST.nextval, ……) 

七、Zookeeper开源客户端框架Curator简介 


</2014-7-29>

<2014-7-30>
一、SpringMVC与struts2比较(主流的Web MVC框架)
1:spring3开发效率高于struts
2:spring3 mvc可以认为已经100%零配置
3:struts2是类级别的拦截， 一个类对应一个request上下文，springmvc是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应所以说从架构本身上 spring3 mvc就容易实现restful url 而struts2的架构实现起来要费劲因为struts2 action的一个方法可以对应一个url而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了 
4:spring3mvc的方法之间基本上独立的，独享request response数据请求数据通过参数获取，处理结果通过ModelMap交回给框架方法之间不共享变量而struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的这不会影响程序运行，却给我们编码 读程序时带来麻烦 
5:由于Struts2需要针对每个Request进行封装，把Request，Session等Servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全。所以在原则上，是比较耗费内存的
----------------
比较了一下strus2与spring3 mvc的差别：
spring3 mvc是方法级别的拦截，拦截到方法后根据参数上的注解，把request数据注入进去，在spring3mvc中，一个方法对应一个request上下文。
而struts2框架是类级别的拦截，每次来了请求就创建一个Action，然后调用setter getter方法把request中的数据注入；struts2实际上是通过setter getter方法与request打交道的；struts2中，一个Action对象对应一个request上下文。

1.spring mvc是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上 spring3 mvc就容易实现restful url。struts2是类级别的拦截， 一个类对应一个request上下文；实现restful url要费劲，因为struts2 action的一个方法可以对应一个url；而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。
2.spring3 mvc的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架方法之间不共享变量,而struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦。
3.spring3 mvc的验证也是一个亮点，支持JSR303，处理ajax的请求更是方便 只需一个注解@ResponseBody ，然后直接返回响应文本即可。


二、RESTful架构
表述性状态转移（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。

目前在三种主流的Web服务实现方案中，因为REST模式的Web服务与复杂的SOAP和XML-RPC对比来讲明显的更加简洁，越来越多的web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务进行图书查找；雅虎提供的Web服务也是REST风格的。

三、java.util.ResourceBundle使用详解
这个类提供软件国际化的捷径。通过此类，可以使您所编写的程序可以：
 
         轻松地本地化或翻译成不同的语言 

         一次处理多个语言环境 

         以后可以轻松地进行修改，支持更多的语言环境 
 
说的简单点，这个类的作用就是读取资源属性文件（properties），然后根据.properties文件的名称信息（本地化信息），匹配当前系统的国别语言信息（也可以程序指定），然后获取相应的properties文件的内容。
 
使用这个类，要注意的一点是，这个properties文件的名字是有规范的：一般的命名规范是： 自定义名_语言代码_国别代码.properties，
如果是默认的，直接写为：自定义名.properties
比如：
myres_en_US.properties
myres_zh_CN.properties
myres.properties
 
当在中文操作系统下，如果myres_zh_CN.properties、myres.properties两个文件都存在，则优先会使用myres_zh_CN.properties，当myres_zh_CN.properties不存在时候，会使用默认的myres.properties。
 
没有提供语言和地区的资源文件是系统默认的资源文件。
 
资源文件都必须是ISO-8859-1编码，因此，对于所有非西方语系的处理，都必须先将之转换为Java Unicode Escape格式。转换方法是通过JDK自带的工具native2ascii.

Locale locale1 = new Locale("zh", "CN"); 
ResourceBundle resb1 = ResourceBundle.getBundle("myres", locale1); 
ResourceBundle resb2 = ResourceBundle.getBundle("myres", Locale.getDefault());
String connStr = resb1.getString("server");


四、Semaphore类
Semaphore当前在多线程环境下被扩放使用，操作系统的信号量是个很重要的概念，在进程控制方面都有应用。Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。比如在Windows下可以设置共享文件的最大客户端访问个数。 
 
Semaphore实现的功能就类似厕所有5个坑，假如有10个人要上厕所，那么同时只能有多少个人去上厕所呢？同时只能有5个人能够占用，当5个人中 的任何一个人让开后，其中等待的另外5个人中又有一个人可以占用了。另外等待的5个人中可以是随机获得优先机会，也可以是按照先来后到的顺序获得机会，这取决于构造Semaphore对象时传入的参数选项。单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合。

Semaphore维护了当前访问的个数，提供同步机制，控制同时访问的个数。在数据结构中链表可以保存“无限”的节点，用Semaphore可以实现有限大小的链表。另外重入锁 ReentrantLock 也可以实现该功能，但实现上要复杂些。 

五、SecureCRt命令
ps -ef  //查看server的进程,以列表形式显示的server进程。
ps 显示当前在系统运行的进程 /usr/bin/ps [选项] -e 显示每个现在运行的进程 -f 生成一个完全的列表
执行如下命令杀掉进程
$ kill -9 491796（查找到得系统进程号）

nohup java cn.aofeng.LoopApplication >Loop.log &
说明：
1）将cn.aofeng.LoopApplication设置成后台运行，并且将标准输出的日志重定向至文件Loop.log。
2）nohup 表示不挂断运行，&表示以后台方式运行。

六、RandomAccessFile类


</2014-7-30>
<2014-8-7>
一、拼音jar包（pinyin4j-2.5.0.jar）
//获取所有的拼音
String []pinyingStr=PinyinHelper.toHanyuPinyinStringArray(src);

二、JSONObject（工具RESTClient）
@RequestMapping(value="/getCatalogList",method=RequestMethod.POST)
public ResponseMessage getCatalogList(@RequestBody JSONObject obj) throws Exception{
}

三、RequestMethod.GET
@RequestMapping(value="/getcollects/{userid}/{pagenum}/{pagesize}",method=RequestMethod.GET)
@ResponseBody
public ResponseMessage getcollects(@PathVariable String userid, @PathVariable Integer pagenum, @PathVariable Integer pagesize) throws Exception{
}

四、XShell

五、Gson
Gson是Google的一个开源项目，可以将Java对象转换成JSON，也可能将JSON转换成Java对象。
Gson里最重要的对象有2个Gson 和 GsonBuilder
Gson有2个最基本的方法
 1) toJson() C 转换java 对象到JSON
 2) fromJson() C 转换JSON到java对象

下面是几个小例子
 
1. toJson() example
 
[java] view plaincopy
01.class TestObjectToJson {  
02.  private int data1 = 100;  
03.  private String data2 = "hello";  
04.}  
05.   
06.TestObjectToJson obj = new TestObjectToJson();  
07.Gson gson = new Gson();  
08.String json = gson.toJson(obj);  
 
 会输出 {"data1":100,"data2":"hello"}
 
2. fromJson() example

[java] view plaincopy
01.import com.google.gson.Gson;  
02.   
03.class TestJsonFromObject {  
04.  private int data1;  
05.  private String data2;  
06.}  
07.   
08.String json = "{'data1':100,'data2':'hello'}";  
09.Gson gson = new Gson();  
10.TestJsonFromObject obj = gson.fromJson(json, TestJsonFromObject.class);  
 
3. 将Java对象的属性转换成指定的JSON名字
 
[java] view plaincopy
01.import com.google.gson.Gson;  
02.   
03.class TestJsonFromObject {  
04.  private int data1;  
05.  private String data2;  
06.}  
07.   
08.String json = "{'data1':100,'data2':'hello'}";  
09.Gson gson = new Gson();  
10.TestJsonFromObject obj = gson.fromJson(json, TestJsonFromObject.class);  
 
 输出结果 {"first_field":"aaaa","SecondField":"bbbbb"}

六、java路径
InputStream inStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("checkParams.xml");

下面是一些得到classpath和当前类的绝对路径的一些方法。你可能需要使用其中的一些方法来得到你需要的资源的绝对路径。
1.FileTest.class.getResource("")　　得到的是当前类FileTest.class文件的URI目录。不包括自己！　如：file:/D:/java/eclipse32/workspace/jbpmtest3/bin/com/test/　

2.FileTest.class.getResource("/")　　得到的是当前的classpath的绝对URI路径。如：file:/D:/java/eclipse32/workspace/jbpmtest3/bin/

3.Thread.currentThread().getContextClassLoader().getResource("")<br>　　得到的也是当前ClassPath的绝对URI路径。<br><br>　　如：file:/D:/java/eclipse32/workspace/jbpmtest3/bin/

4.FileTest.class.getClassLoader().getResource("")<br>　　得到的也是当前ClassPath的绝对URI路径。　　如：file:/D:/java/eclipse32/workspace/jbpmtest3/bin/
5.ClassLoader.getSystemResource("")<br>　　得到的也是当前ClassPath的绝对URI路径。　　如：file:/D:/java/eclipse32/workspace/jbpmtest3/bin/　

我推荐使用Thread.currentThread().getContextClassLoader().getResource("")来得到当前的classpath的绝对路径的URI表示法。

七、Digester
digester使用方法 
　　使用者通过调用Digester类的相关方法，来创建匹配模式与规则的映射序列。
　　比如，调用addSetProperties(String pattern)，向Digester中加入SetPropertiesRule。
　　基本步骤如下:
　　1.创建Digester对象实例。
　　2.设置该Digester对象的配置属性(可选)。
　　3.将需要的初始对象push到该Digester对象的对象栈上(可选)。
　　4.需要注册所有的XML元素匹配模式与处理规则之间的映射关系。
　　5.用digester.parse()解析的XML文档对象，得到目标对象。 
-------
private static void init() {
	InputStream inStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("checkParams.xml");
	Digester digester = new Digester();
	digester.addObjectCreate("checkParams", CheckParams.class);
	digester.addObjectCreate("checkParams/checkParam", CheckParam.class);
	digester.addSetProperties("checkParams/checkParam");
	digester.addObjectCreate("checkParams/checkParam/parameter", Parameter.class);
	digester.addSetProperties("checkParams/checkParam/parameter");
	digester.addSetNext("checkParams/checkParam/parameter", "addParam");
	digester.addSetNext("checkParams/checkParam", "addCheckParam");
	try {
		CheckParams checkParams = (CheckParams) digester.parse(inStream);
		List<CheckParam> list = checkParams.getCheckParamList();
		for (CheckParam checkParam : list) {
			rulesMap.put(checkParam.getUrl(), checkParam.getParamList());
		}
	} catch(Exception ex) {
		LOGGER.error(ex.getMessage(), ex);
	}
}
xml映射到javabean
-------
<checkParams>
	<checkParam url="/createNetdisk">
		<parameter name="diskType" type="Integer" maxLength="-1" isNull="1"/>
    </checkParam>
</checkParams>

</2014-8-7>

<2014-8-8>
一、mybatis大于
第一种方法：
用了转义字符把>和<替换掉，然后就没有问题了。
SELECT * FROM test WHERE 1 = 1 AND start_date  &lt;= CURRENT_DATE AND end_date &gt;= CURRENT_DATE

附：XML转义字符
&lt; < 小于号                                           
&gt; > 大于号
&amp; & 和
&apos; ’ 单引号
&quot; " 双引号

第二种方法：

因为这个是xml格式的，所以不允许出现类似“>”这样的字符，但是都可以使用<![CDATA[ ]]>符号进行说明，将此类符号不进行解析 
你的可以写成这个： 
mapper文件示例代码
<![CDATA[ when min(starttime)<='12:00' and max(endtime)<='12:00' ]]>    
</2014-8-8>

<2014-8-9>
一、Java(TM) Platform SE binary 打开jar资料
ava(TM) Platform SE binary 打开jar文件
Java(TM) Platform SE binary 打开jar文件 
1．进入“我的电脑”――〉“工具”――〉“文件夹选项”――〉“文件类型”――〉找到JAR类型文件

2．找到 "jar扩展名的详细信息"里面的“高级”――〉选择“操作”中的open ――〉“编辑”――〉找到"用于执行操作的应用程序"
点击右侧的“浏览”，找到jdk的安装目录下的jre-bin-javaw.exe,（比如我的路径：D:\softdir\jdk\jre\bin\javaw.exe），
设置完成,点击确定
 说明：如果没有jar文件类型,则点击新建，新建完成之后，其余操作和上面类似。
windows下 javaw.exe 无法打开 *.jar文件问题的解决
<script type="text/javascript"></script>0人收藏此文章, <script type="text/javascript"></script>我要收藏 发表于7个月前 , 已有724次阅读 共0个评论
选择打开方式找到jre/bin/javaw.exe 还是无法打开。后来网上找到了方法：
在注册表（cmd -> regedit）中找到HKEY_CLASSES_ROOT/Applications/javaw.exe/shell/open/command的值原来是"C:\Program Files\Java\jre7\bin\javaw.exe"  "%1"，中间加入“-jar”改成"C:\Program Files\Java\jre7\bin\javaw.exe" -jar "%1"就行了

原来打开方式都在注册表里啊，我原来企图用javaws.exe和java.exe打开，多了好几个打开方式，弄的乱乱的，只要把注册表HKEY_CLASSES_ROOT/Applications/里的相应文件夹删掉就行了。

另外我发现，在终端中输入javaw xxx.jar无法打开，要输入javaw -jar xxx.jar才可以
</2014-8-9>

<2014-8-11>
一、inner join、left join、right join、full outer区别
left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 ；
left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.
换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID).B表记录不足的地方均为NULL.

right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录；
inner join(等值连接) 只返回两个表中联结字段相等的行；
inner join并不以谁为基础,它只显示符合条件的记录.

A表(a1,b1,c1)      B表(a2,b2)
a1   b1   c1       a2    b2
01   数学 95       01    张三
02   语文 90       02    李四
03   英语 80       04    王五
select A.*,B.* from A 
inner join B on(A.a1=B.a2)
结果是：
a1   b1   c1       a2    b2
01   数学 95       01    张三
02   语文 90       02    李四

select A.*,B.* from A 
left outer join B on(A.a1=B.a2)
结果是:
a1   b1   c1       a2    b2
01   数学 95       01    张三
02   语文 90       02    李四
03   英语 80       NULL  NULL

select A.*,B.* from A 
right outer join B on(A.a1=B.a2)
结果是:
a1   b1   c1       a2    b2
01   数学 95       01    张三
02   语文 90       02    李四
NULL NULL NULL     04    王五

select A.*,B.* from A 
full outer join B on(A.a1=B.a2)
结果是:
a1   b1   c1       a2    b2
01   数学 95       01    张三
02   语文 90       02    李四
03   英语 80       NULL  NULL
NULL NULL NULL     04    王五

二、mybatis语句
<select id="selectPeriodBySubject" parameterType="hashmap" resultMap="SubjectPeriodMap">
		SELECT T3.PERIOD_ID, T3.PERIOD_NAME, T2.SUBJECT_ID, T2.SUBJECT_NAME
		  FROM T_BASE_PERIOD T3
		  INNER JOIN (select PERIOD_ID, SUBJECT_ID
		               from T_TEXTBOOK
		              WHERE SUBJECT_ID = #{SUBJECT_ID}
		              GROUP BY PERIOD_ID, SUBJECT_ID) T1
		    ON T3.PERIOD_ID = T1.PERIOD_ID
		  INNER JOIN T_BASE_SUBJECT T2
		    ON T1.SUBJECT_ID = T2.SUBJECT_ID
		 WHERE T3.PERIOD_ID IN 
			<foreach item="item" index="index" collection="PERIOD_IDS" open="(" separator="," close=")">
		    	#{item}
        	</foreach> 
         ORDER BY T3.SORT_NUM
	</select>

<!-- where clause -->
	<sql id="whereClause">
		<where>
			<if test="volumeName != null and volumeName != ''">
				VOLUME_NAME like '%' || #{volumeName} || '%'
			</if>
			<if test="status != null and status != ''">
				AND STATUS like #{status}
			</if>
		</where>
	</sql>

<if test="timeStart != null and timeStart != ''">
	<![CDATA[   and t1.CREATE_TIME >=  to_date(#{timeStart}, 'yyyy-mm-dd hh24:mi:ss')   ]]>
</if>

select 'VOL' || SEQ_ATTACH_FILE.NEXTVAL from dual
其中‘VOL’为添加的字符串；

decode函数：
DECODE(command,
0,’None’,
2,’Insert’,
3,’Select’,
6,’Update’,
7,’Delete’,
8,’Drop’,
‘Other’)

DECODE(VALUE,'0','1','2')
若value为0，则为1，否则为2

二、Oracle start with...connect by prior子句实现递归查询
Oracle中的select语句可以用start with...connect by prior子句实现递归查询，connect by 是结构化查询中用到的，其基本语法是：

select ... from <TableName>
where <Conditional-1>
start with <Conditional-2>
connect by <Conditional-3>;

<Conditional-1>：过滤条件，用于对返回的所有记录进行过滤。
<Conditional-2>：查询结果重起始根结点的限定条件。
<Conditional-3>：连接条件

create table t2(
root_id number,
id number,
name varchar(5),
description varchar(10)
);

insert into t2(root_id,id,name,description) values(0,1,'a','aaa');
insert into t2(root_id,id,name,description) values(1,2,'a1','aaa1');
insert into t2(root_id,id,name,description) values(1,3,'a2','aaa2');
insert into t2(root_id,id,name,description) values(0,4,'b','bbb');
insert into t2(root_id,id,name,description) values(4,5,'b1','bbb1');
insert into t2(root_id,id,name,description) values(4,6,'b2','bbb2');
获取完整树：
select * from t2 start with root_id = 0 connect by prior id = root_id;
 
获取特定子树：

select * from t2 start with id = 1 connect by prior id = root_id;

select * from t2 start with id = 4 connect by prior id = root_id;

如果connect by prior中的prior被省略，则查询将不进行深层递归。

select * from t2 start with root_id = 0 connect by id = root_id;

select * from t2 start with id = 1 connect by id = root_id;

三、NVL
NVL是Oracle PL/SQL中的一个函数。它的格式是NVL( string1, replace_with)。它的功能是如果string1为NULL，则NVL函数返回replace_with的值，否则返回string1的值，如果两个参数都为NULL ，则返回NULL。
SELECT   NVL(avg(SCORE), 0.0)
		FROM     CMSUSER.T_SCORE
		WHERE    PRODUCT_CODE = #{productCode}
tring1和replace_with必须为同一数据类型，除非显式的使用TO_CHAR函数进行类型转换。

NVL2(E1, E2, E3)的功能为：如果E1为NULL，则函数返回E3，否则返回E2。

四、like
select * from table_name 
是查询出table_name 里所有的记录
select * from table_name where column_name like '%%' 
由于%是代替所有，‘%%’代替所有，但并不表示代替空值，所以后一条记录和前一条的区别是，前一条是查询所有记录，后一条是查询column_name 值 不为空的所有记录。

五、pom.xml的jar包
junit.jar
Junit包，当你运行Hibernate自带的测试代码的时候需要，否则就不用。
c3p0.jar
C3PO是一个数据库连接池，Hibernate可以配置为使用C3PO连接池。如果你准备用这个连接池，就需要这个jar包。
titles框架jar包：
<dependency>
	<groupId>org.apache.tiles</groupId>
	<artifactId>tiles-jsp</artifactId>
	<version>2.2.2</version>
</dependency>

<dependency>
	<groupId>org.apache.tiles</groupId>
	<artifactId>tiles-core</artifactId>
	<version>2.2.2</version>
</dependency>

<dependency>
	<groupId>org.apache.tiles</groupId>
	<artifactId>tiles-api</artifactId>
	<version>2.2.2</version>
</dependency>

<dependency>
	<groupId>org.apache.tiles</groupId>
	<artifactId>tiles-servlet</artifactId>
	<version>2.2.2</version>
</dependency>

<dependency>
	<groupId>org.apache.tiles</groupId>
	<artifactId>tiles-template</artifactId>
	<version>2.2.2</version>
</dependency>


六、velocity
Velocity是一个基于java的模板引擎（template engine）。它允许任何人仅仅简单的使用模板语言（template language）来引用由java代码定义的对象。 当Velocity应用于web开发时，界面设计人员可以和java程序开发人员同步开发一个遵循MVC架构的web站点，也就是说，页面设计人员可以只关注页面的显示效果，而由java程序开发人员关注业务逻辑编码。Velocity将java代码从web页面中分离出来，这样为web站点的长期维护提供了便利，同时也为我们在JSP和PHP之外又提供了一种可选的方案。 Velocity的能力远不止web站点开发这个领域，例如，它可以从模板（template）产生SQL和PostScript、XML，它也可以被当作一个独立工具来产生源代码和报告，或者作为其他系统的集成组件使用。Velocity也可以为Turbine web开发架构提供模板服务（template service）。Velocity+Turbine提供一个模板服务的方式允许一个web应用以一个真正的MVC模型进行开发。 【VeloEclipse ：Velocity在Eclipse平台下的一个辅助开发插件】

七、面向切面编程AOP
 在以往的JDBCTemplate中事务提交成功，异常处理都是通过Try/Catch 来完成，而在Spring中。Spring容器集成了TransactionTemplate，她封装了所有对事务处理的功能，包括异常时事务回滚，操作成功时数据提交等复杂业务功能。这都是由Spring容器来管理，大大减少了程序员的代码量，也对事务有了很好的管理控制。Hibernate中也有对事务的管理，hibernate中事务管理是通过SessionFactory创建和维护Session来完成。而Spring对SessionFactory配置也进行了整合，不需要在通过hibernate.cfg.xml来对SessionaFactory进行设定。这样的话就可以很好的利用Sping对事务管理强大功能。避免了每次对数据操作都要现获得Session实例来启动事务/提交/回滚事务还有繁琐的Try/Catch操作。这些也就是Spring中的AOP（面向切面编程）机制很好的应用。一方面使开发业务逻辑更清晰、专业分工更加容易进行。另一方面就是应用Spirng  AOP隔离降低了程序的耦合性使我们可以在不同的应用中将各个切面结合起来使用大大提高了代码重用度 


</2014-8-11>

<2014-8-12>
一、SecureCRT命令
TMOUT=0 防止断线
top
</2014-8-12>

<2014-8-13>
一、redis

二、SSH Secure Shell

三、WinSCP
WinSCP是一个Windows环境下使用SSH的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能就是在本地与远程计算机间安全的复制文件。

四、XShell
Xshell 是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。
Xshell 和SecureCRT的比较：
Screen不会闪屏，并且可以回滚，这个功能比较好用。Script的执行顺序可以调整，SecureCRT的这个功能相较而言比较死板，不过可以同时发送指令到多个session，这个功能较好。键盘映射的兼容性比较好，不需要自己去改映射，可以展现tunnel等。支持布局切换，像gnome-terminal。缺憾是对Unicode制表符支持不够好，内置的sftp不怎么符合用户的操作习惯（该公司有另外的xftp）。许可相对便宜，对个人、教育用户是免费的。
XShell 和Putty& Pietty的比较：
支持ZModem协议，putty虽有leputty据说可以实现， :( Session保存在文件中而非注册表，管理方便支持tab、自定义脚本、保存密码、多机管理…putty是自由软件，和商用的XShell比较不是很合适。putty也有很多插件可以实现部分有缺憾的功能，个人平常还是以putty为主，功能够用，速度飞快。大量机器的管理还是XShell合适。
注意，XShell在商业环境使用下是需要买许可的。


</2014-8-13>
<2014-8-14>
一、flexpaper
FlexPaper是一个开源轻量级的在浏览器上显示各种文档的组件，被设计用来与PDF2SWF一起使用， 使在Flex中显示PDF成为可能，而这个过程并无需PDF软件环境的支持。它可以被当做Flex的库来使用。
另外你也可以通过将一些例如Word、PPT等文档转成PDF，然后实现在线浏览。

一. 使用PDF2SWF准备好你的文档
首先要将PDF转成SWF，这步可以使用开源的SwfTools自动完成
1.下载安装 SwfTools，当前最新版本是0.9
2. 转换PDF到SWF，可以通过命令行的方式，例如将Paper3.pdf转换成Paper3.swf
C:\SWFTools\pdf2swf Paper3.pdf -o Paper3.swf
二. 使用已经编译好的FlexPaper的flash版本浏览你的文档
下载并解压出已经编译好的FlexPaper
zip文件包含一个例子文件叫做FlexPaperViewer.html，它向你展示了需要传给FlexPaper的 基本参数
var params = {
SwfFile : "Paper.swf",
Scale : 0.6
}
swfobject.embedSWF("FlexPaperViewer.swf","cb","500","500","9.0.0","js/swfobject/expressInstall.swf", params);
//SwfFile参数是你想显示的文件，Scale是0-1之间的数，表示显示的放大参数
复制你创建出来的swf和PDF2SWF到解压缩出的相同目录
确定你添加了FlexPaperViewer.swf。

二、oracle rowid
ROWID为该表行的唯一标识，是一个伪列，可以用在SELECT中，但不可以用INSERT, UPDATE来修改该值。
在select查询时：select t.*,rowid from xxx t 相当于 select * from xxx t for update


三、内网和外网
先说明一下什么是外网(也称为公网)?:
使用ADSL的用户，如果只有一个用户一台计算机在使用此宽带，没有使用路由功能，而是用拨号软件直接拨号上网的，这种情况下，该用户目前所处的网络为外网,外网的用户都拥有一个属于自己的独立IP地址.公网的计算机和Internet上的其他计算机可随意互相访问。
什么是内网?
内网接入方式：上网的计算机得到的IP地址是Inetnet上的保留地址，保留地址有如下3种形式：　　　　 
10.x.x.x       172.16.x.x至172.31.x.x     192.168.x.x 　 
内网的计算机以NAT（网络地址转换）协议，通过一个公共的网关访问Internet。内网的计算机可向Internet上的其他计算机发送连接请求，但Internet上其他的计算机无法向内网的计算机发送连接请求。  
NAT（Network Address Translator）是网络地址转换，它实现内网的IP地址与公网的地址之间的相互转换，将大量的内网IP地址转换为一个或少量的公网IP地址，减少对公网IP地址的占用。NAT的最典型应用是：在一个局域网内，只需要一台计算机连接上Internet，就可以利用NAT共享Internet连接，使局域网内其他计算机也可以上网。使用NAT协议，局域网内的计算机可以访问Internet上的计算机，但Internet上的计算机无法访问局域网内的计算机。 
Windows操作系统的Internet连接共享、sygate、winroute、unix/linux的natd等软件，都是使用NAT协议来共享Internet连接。　　所有ISP（Internet服务提供商）提供的内网Internet接入方式，几乎都是基于NAT协议的。  
现在知道了什么是内网什么是外网那我们属于那种类型呢?
查看自己的IP地址
A.使用DOS命令:
点 开始--运行--CMD 在打开的MS-DOS模式下，输入ipconfig.exe，也是一样可以显示详细的IP信息，只不过此画面是在DOS下而已。
附IPCONFIG相关参数(可略过)
1、/all 
显示所有网络适配器（网卡、拨号连接等）的完整TCP/IP配置信息。与不带参数的用法相比，它的信息更全更多，如IP是否动态分配、显示网卡的物理地址等。 
2、/batch 文件名 
将Ipconfig所显示信息以文本方式写入指定文件。此参数可用来备份本机的网络配置。 
3、/release_all和/release N 
释放全部（或指定）适配器的由 DHCP分配的动态IP 
地址。此参数适用于IP地址非静态分配的网卡，通常和下文的renew参数结合使用。 
4、ipconfig /renew_all或ipconfig /renew N 
为全部（或指定）适配器重新分配IP地址。此参数同样仅适用于IP地址非静态分配的网卡，通常和上文的release参数结合使用。 
B.点 开始-设置-控制面板(或是直接点网络连接)-网络和 Internet 连接-网络连接    也可以直接双击屏幕右下角的小电脑标志<该标志只有在设置了"本地连接属性"里的"连接后在通知区域显示图标"和"此连接在受限制或无连接时通知我"这两个选项后无论是你否有网络连接都会在屏幕右下角的任务栏显示一个两台小电脑的标志>
在打开的窗口中双击"本地连接"就会打开网络连接状态对话框,点"支持"选项卡,就能看到自己的IP地址
如果你的IP地址属于保留地址(保留地址开头为:10.x.x.x       172.16.x.x至172.31.x.x     192.168.x.x)那么你的计算机就是运行在局域网内。
一般IP在以下范围内的都是内网IP： 
10.0.0.0-10.255.255.255
172.16.0.0-172.31.255.255
192.168.0.0-192.168.255.255

内网IP有个特点，就是子网掩码的最后一位都不是255

四、127.0.0.1
127.0.0.1是回送地址，指本地机，一般用来测试使用。回送地址（127.x.x.x）是本机回送地址（Loopback Address），即主机IP堆栈内部的IP地址，主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回，不进行任何网络传输。
回送地址：127.0.0.1。一般用于测试使用。例如：ping 127.0.0.1 来测试本机TCP/IP是否正常。
在有类IP地址的规定中，第一部分是1~126为A类地址，128~191为B类地址，那么中间留的127.0.0.1被称为本地回环地址，主要作用有两个：一是测试本机的网络配置，能PING通127.0.0.1说明本机的网卡和IP协议安装都没有问题；另一个作用是某些SERVER/CLIENT的应用程序在运行时需调用服务器上的资源，一般要指定SERVER的IP地址，但当该程序要在同一台机器上运行而没有别的SERVER时就可以把SERVER的资源装在本机，SERVER的IP地址设为127.0.0.1也同样可以运行。

IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。
A类：第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。
B类：前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。
C类：前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。
D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户。
E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。

五、solr之Field、CopyField、DynamicField
Field就是一个字段，定义一个Field很简单：
<fields>
 <field name="productCode" type="string" indexed="true" stored="true" required="true"/>
 <field name="score" type="float" indexed="true" stored="true"/>
 <field name="resIdList" type="string" indexed="true" stored="true" multiValued="true"/>
 <!-- copy field -->
 <field name="text" type="text_general" indexed="true" stored="false" multiValued="true" />
</fields>
主键：
<uniqueKey>productCode</uniqueKey>

你可能想让document的一些字段可以多次使用。solr 有一个字段复制机制，可以提交多个不同类型字段集中到一个字段。字段复制主要涉及两个概念，source和destination，一个是要复制的字段，另一个是要复制到哪个字段，以下是个例子：
<copyField source="cat" dest="text" maxChars="30000"/>
上例中，如果text字段有数据的话，cat字段的内容将被添加到text字段中。maxChars 参数，一个int类型参数，用于限制复制的字符数。
source和destination都支持通配符。以下是一个将所有以 _t 结尾的字段全部复制到text字段中。
<copyField source="*_t" dest="text" maxChars="25000"/>

其实说的简单一点，比如现在你要查询包涵"Java"的博客， 那么你肯定要查内容，标题是否包含Java，但是solr不能像SQL那样，where tittle like '%Java%'  or  content like '%Java%'.   这个时候copyField就派上用场了， 定义一个新字段，将title和content 复制到这个新字段，索引的时候，直接从这个新字段查询，这样就达到目地了。  这便是copyField的典型应用场景 。注意：如果dest由多个source构成，就需要将其指定为multiValued。
在网上找了一个例子：
[html] view plaincopy
<schema name="eshequn.post.db_post.0" version="1.1"    
    xmlns:xi="http://www.w3.org/2001/XInclude">    
     <fields>    
        <!-- for title -->    
        <field name="t" type="text" indexed="true" stored="false" />    
        <!-- for abstract -->    
        <field name="a" type="text" indexed="true" stored="false" />    
        <!-- for title and abstract -->    
        <field name="ta" type="text" indexed="true" stored="false" multiValued="true"/>    
    </fields>    
    <copyField source="t" dest="ta" />    
    <copyField source="a" dest="ta" />    
</schema>
DynamicField：
动态字段（Dynamic fields）允许 solr 索引没有在 schema 中明确定义的字段。这个在忘记定义一些字段时很有用。动态字段可以让系统更灵活，通用性更强。
动态字段和常规字段类似，除了它名字中包含一个通配符外，在索引文档时，一个字段如果在常规字段中没有匹配时，将到动态字段中匹配。
假设schema中定义了一个叫*_i的动态动态字段，如果要索引一个叫 cost_i 的字段，但是 schema 中不存在 cost_i 的字段，这样 cost_i  将被索引到 *_i 字段中。
动态字段也是定义在 schema.xml 文件中，和其他字段一样，它也有个名词，字段类型，和属性。
<dynamicField name="*_i" type="sint" indexed="true" stored="true"/>
建议在 schema.xml 定义一些基本的动态字段，以备扩展之用。

</2014-8-14>

<2014-8-16>
一、document.getElementById().contentWindow
document.getElementByid("AAA"),查找页面中id=“AAA”的选项。
在页面中frameset将页面分为多个窗口
<iframe id="AAA" src="xxxA.html" />
<iframe id="BBB" src="xxxB.html" />
    比如上面两句话，就是说将这个页面分为两个页面，上部分id为AAA的页面，这个页面显示的内容为xxxA.html。下边部分同理为xxxB.html页面内容。document.getElementByid("AAA"),就是查找到页面id为AAA的页面，然后进行改变，id为BBB的部分是不变的。
    contentWindow属性是指指定的frame或者iframe所在的window对象，在IE中iframe或者frame的contentWindow属性可以省略，但在Firefox中如果要对iframe对象进行编辑则必须指定contentWindow属性。contentWindow下有很多方法对应不同的打开样式，这下方法是不可以省略的，比如contentWindow.navigate(url) 参数列表除了有url外还可以有其他的，但url是必须有的，这个url在同一位置代替xxxA，html。
     和document.getElementById()最常常一起用的就是parent。比如在这个页面AAA，你想从id
为"AAA"跳转到"BBB"去"BBB"进行操作，id="AAA"页面上写parent.document.getElementByid("BBB").navigate("xxxC.html")。这样做后你就将xxxC.html代替了xxxB.html。id=“AAA”是不变的，你到了id为BBB页面进行操作，以后的所有请求操作都在id="BBB"上进行
var uploadFrame = document.getElementById("uploadFrame").contentWindow;
var attachFileIds = uploadFrame.document.getElementsByName("attachFileId");
$("#fid").val(attachFileIds[0].value);

二、Filter
其中最重要的就是filter功能.它使用户可以改变一个request和修改一个response. Filter 不是一个servlet，它不能产生一个response，它能够在一个request到达servlet之前预处理request，也可以在response离开servlet时处理response.换种说法，filter其实是一个“servlet chaining“（servlet 链）.
包括
1. 在servlet被调用之前截获；
2. 在servlet被调用之前检查servlet request;
3. 根据需要修改request头和request数据；
4. 根据需要修改response头和response数据；
5. 在servlet被调用之后截获.
你能够配置一个filter 到一个或多个servlet；单个servlet或servlet组能够被多个filter 使用。几个实用的filter 包括：用户辨认filter，日志filter，审核filter，加密filter，符号filter，能改变xml内容的XSLT filter等。

三、web.xml 中的listener、 filter、servlet 加载顺序及其详解
首先可以肯定的是，加载顺序与它们在 web.xml 文件中的先后顺序无关。即不会因为 filter 写在 listener 的前面而会先加载 filter。最终得出的结论是：listener -> filter -> servlet

        同时还存在着这样一种配置节：context-param，它用于向 ServletContext 提供键值对，即应用程序上下文信息。我们的 listener, filter 等在初始化时会用到这些上下文中的信息，那么 context-param 配置节是不是应该写在 listener 配置节前呢？实际上 context-param 配置节可写在任意位置，因此真正的加载顺序为：context-param -> listener -> filter -> servlet

        对于某类配置节而言，与它们出现的顺序是有关的。以 filter 为例，web.xml 中当然可以定义多个 filter，与 filter 相关的一个配置节是 filter-mapping，这里一定要注意，对于拥有相同 filter-name 的 filter 和 filter-mapping 配置节而言，filter-mapping 必须出现在 filter 之后，否则当解析到 filter-mapping 时，它所对应的 filter-name 还未定义。web 容器启动时初始化每个 filter 时，是按照 filter 配置节出现的顺序来初始化的，当请求资源匹配多个 filter-mapping 时，filter 拦截资源是按照 filter-mapping 配置节出现的顺序来依次调用 doFilter() 方法的。


</2014-8-16>
<2014-8-18>
一、浏览器添加扩展程序
.crx
是chrome浏览器的扩展文件。
.xpi
xpi文件是firefox浏览器的扩展文件，在IE浏览器不能安装使用。如果你使用firefox浏览器，打开浏览器，把xpi文件拖到浏览器界面，firefox就可以安装这个xpi扩展。

二、Listener
监听器也叫Listener，是Servlet的监听器，它可以监听客户端的请求、服务端的操作等。通过监听器，可以自动激发一些操作，比如监听在线的用户的数量。当增加一个HttpSession时，就激发sessionCreated(HttpSessionEvent   se)方法，这样
就可以给在线人数加1。常用的监听接口有以下几个：
ServletContextAttributeListener监听对ServletContext属性的操作，比如增加、删除、修改属性。
ServletContextListener监听ServletContext。当创建ServletContext时，激发 contextInitialized(ServletContextEvent   sce)方法；当销毁ServletContext时，激发contextDestroyed(ServletContextEvent   sce)方法。
HttpSessionListener监听HttpSession的操作。当创建一个Session时，激发session   Created(HttpSessionEvent   se)方法；当销毁一个Session时，激发sessionDestroyed   (HttpSessionEvent   se)方法。
HttpSessionAttributeListener监听HttpSession中的属性的操作。当在Session增加一个属性时，激发 attributeAdded(HttpSessionBindingEvent   se)   方法；当在Session删除一个属性时，激发attributeRemoved(HttpSessionBindingEvent   se)方法；当在Session属性被重新设置时，激发attributeReplaced(HttpSessionBindingEvent   se)   方法。


1.启动一个WEB项目的时候,容器(如:Tomcat)会去读它的配置文件web.xml.读两个节点: <listener></listener> 和 <context-param></context-param> 
2.紧接着,容器创建一个ServletContext(上下文),这个WEB项目所有部分都将共享这个上下文. 
3.容器将<context-param></context-param>转化为键值对,并交给ServletContext. 
4.容器创建<listener></listener>中的类实例,即创建监听. 
5.在监听中会有contextInitialized(ServletContextEvent args)初始化方法,在这个方法中获得 
ServletContext = ServletContextEvent.getServletContext(); 
context-param的值 = ServletContext.getInitParameter("context-param的键"); 
6.得到这个context-param的值之后,你就可以做一些操作了.注意,这个时候你的WEB项目还没有完全启动完成.这个动作会比所有的Servlet都要早. 
换句话说,这个时候,你对<context-param>中的键值做的操作,将在你的WEB项目完全启动之前被执行. 
7.你可能想在项目启动之前就打开数据库. 
那么这里就可以在<context-param>中设置数据库的连接方式,在监听类中初始化数据库的连接. 
8.这个监听是自己写的一个类,除了初始化方法,它还有销毁方法.用于关闭应用前释放资源.比如说数据库连接的关闭.

三、获得工程路径
String path = 类.class.getClassLoader().getResource("").getPath();
path = path.substring(0, path.lastIndexOf("/"));
path = path.substring(0, path.lastIndexOf("/"));

四、HttpURLConnection
最常用的Http请求无非是get和post，get请求可以获取静态页面，也可以把参数放在URL字串后面，传递给servlet，post与get的不同之处在于post的参数不是放在URL字串里面，而是放在http请求的正文内。
在Java中可以使用HttpURLConnection发起这两种请求，了解此类，对于了解soap，和编写servlet的自动测试代码都有很大的帮助。

public class HttpInvoker {

    public static final String GET_URL = "http://localhost:8080/welcome1";

    public static final String POST_URL = "http://localhost:8080/welcome1";

    public static void readContentFromGet() throws IOException {
        // 拼凑get请求的URL字串，使用URLEncoder.encode对特殊和不可见字符进行编码
        String getURL = GET_URL + "?username="
                + URLEncoder.encode("fat man", "utf-8");
        URL getUrl = new URL(getURL);
        // 根据拼凑的URL，打开连接，URL.openConnection函数会根据URL的类型，
        // 返回不同的URLConnection子类的对象，这里URL是一个http，因此实际返回的是HttpURLConnection
        HttpURLConnection connection = (HttpURLConnection) getUrl
                .openConnection();
        // 进行连接，但是实际上get request要在下一句的connection.getInputStream()函数中才会真正发到
        // 服务器
        connection.connect();
        // 取得输入流，并使用Reader读取
        BufferedReader reader = new BufferedReader(new InputStreamReader(
                connection.getInputStream()));
        System.out.println("=============================");
        System.out.println("Contents of get request");
        System.out.println("=============================");
        String lines;
        while ((lines = reader.readLine()) != null) {
            System.out.println(lines);
        }
        reader.close();
        // 断开连接
        connection.disconnect();
        System.out.println("=============================");
        System.out.println("Contents of get request ends");
        System.out.println("=============================");
    }

    public static void readContentFromPost() throws IOException {
        // Post请求的url，与get不同的是不需要带参数
        URL postUrl = new URL(POST_URL);
        // 打开连接
        HttpURLConnection connection = (HttpURLConnection) postUrl
                .openConnection();
        // Output to the connection. Default is
        // false, set to true because post
        // method must write something to the
        // connection
        // 设置是否向connection输出，因为这个是post请求，参数要放在
        // http正文内，因此需要设为true
        connection.setDoOutput(true);
        // Read from the connection. Default is true.
        connection.setDoInput(true);
        // Set the post method. Default is GET
        connection.setRequestMethod("POST");
        // Post cannot use caches
        // Post 请求不能使用缓存
        connection.setUseCaches(false);
        // This method takes effects to
        // every instances of this class.
        // URLConnection.setFollowRedirects是static函数，作用于所有的URLConnection对象。
        // connection.setFollowRedirects(true);

        // This methods only
        // takes effacts to this
        // instance.
        // URLConnection.setInstanceFollowRedirects是成员函数，仅作用于当前函数
        connection.setInstanceFollowRedirects(true);
        // Set the content type to urlencoded,
        // because we will write
        // some URL-encoded content to the
        // connection. Settings above must be set before connect!
        // 配置本次连接的Content-type，配置为application/x-www-form-urlencoded的
        // 意思是正文是urlencoded编码过的form参数，下面我们可以看到我们对正文内容使用URLEncoder.encode
        // 进行编码
        connection.setRequestProperty("Content-Type",
                "application/x-www-form-urlencoded");
        // 连接，从postUrl.openConnection()至此的配置必须要在connect之前完成，
        // 要注意的是connection.getOutputStream会隐含的进行connect。
        connection.connect();
        DataOutputStream out = new DataOutputStream(connection
                .getOutputStream());
        // The URL-encoded contend
        // 正文，正文内容其实跟get的URL中'?'后的参数字符串一致
        String content = "firstname=" + URLEncoder.encode("一个大肥人", "utf-8");
        // DataOutputStream.writeBytes将字符串中的16位的unicode字符以8位的字符形式写道流里面
        out.writeBytes(content); 

        out.flush();
        out.close(); // flush and close
        BufferedReader reader = new BufferedReader(new InputStreamReader(
                connection.getInputStream()));
        String line;
        System.out.println("=============================");
        System.out.println("Contents of post request");
        System.out.println("=============================");
        while ((line = reader.readLine()) != null) {
            System.out.println(line);
        }
        System.out.println("=============================");
        System.out.println("Contents of post request ends");
        System.out.println("=============================");
        reader.close();
        connection.disconnect();
    }

}

五、java.net.URL类详解
ava.net.URL中定义了URL相关的操作，其主要利用的是openStream();方法来返回一个InputStream，然后可以使用InputStreamReader和BufferedReader来封装从而获取网上已发布的资源内容。具体使用如下:
package com.dylan.java.net;  
  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStream;  
import java.io.InputStreamReader;  
import java.net.MalformedURLException;  
import java.net.URL;  
  
public class TestURL {  
  
    public static void main(String[] args) {  
        try {  
            // 创建一个对象  
            URL url = new URL("http://www.baidu.com/");  
            // URL对象的openStream() 方法返回的是一个InputStream输入流  
            InputStream is = url.openStream();  
  
            /* 
             * 读取输入流并且转化成为BufferedReader, 利用BufferedReader的rendLine()方法读出内容 
             */  
            InputStreamReader isr = new InputStreamReader(is);  
            BufferedReader bf = new BufferedReader(isr);  
            String str;  
            while ((str = bf.readLine()) != null) {  
                System.out.println(str);  
            }  
   
            /*这种写法不能读出全部网页内容，第一行没有打印出来，只打印出来了中间部分 ？ 
             * while (bf.readLine() != null) { //读取一行
             * System.out.println(bf.readLine()); } //再读取一行，当然不能输出第一行
			 * bf.readLine()是读取下一行的。。
             */  
  
        } catch (MalformedURLException e) {  
            e.printStackTrace();  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}  

六、<iframe>问题导致页面显示错误
<iframe/>
<iframe></iframe>

七、错误com.alibaba.dubbo.rpc.RpcException: Failed to invoke the method
最后无意间看到报错信息Serializable关键字，顿时豁然开朗：这个项目本身是远程调用实现，在传输对象过程中，被传输的对象必须实现序列化


</2014-8-18>

<2014-8-20>
一、显示sql语句
在log4j.properties文件中，下列项加上DEBUG：
log4j.rootLogger=DEBUG,debug,CONSOLE,LOGFILE

# ibatis logging configuration..
log4j.logger.com.ibatis=DEBUG,CONSOLE,LOGFILE
log4j.logger.com.ibatis.common.jdbc.ScriptRunner=DEBUG,CONSOLE,LOGFILE
log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG,CONSOLE,LOGFILE
log4j.logger.java.sql.Connection=DEBUG,CONSOLE,LOGFILE
log4j.logger.java.sql.Statement=DEBUG,CONSOLE,LOGFILE
log4j.logger.java.sql.PreparedStatement=DEBUG,CONSOLE,LOGFILE
log4j.logger.java.sql.ResultSet=DEBUG,CONSOLE,LOGFILE
</2014-8-20>

<2014-8-21>
一、jQuery中$.fn的用法
$.fn是指jquery的命名空间，加上fn上的方法及属性，会对jquery实例每一个有效。 
如扩展$.fn.abc(),即$.fn.abc()是对jquery扩展了一个abc方法,那么后面你的每一个jquery实例都可以引用这个方法了. 
那么你可以这样子：$("#div").abc(); 

jQuery为开发插件提拱了两个方法，分别是： 

jQuery.extend(object);为扩展jQuery类本身.为类添加新的方法。 
jQuery.fn.extend(object);给jQuery对象添加方法。 

fn是什么东西呢。查看jQuery代码，就不难发现。 
代码如下:
jQuery.fn = jQuery.prototype ={ 
　　　init: function( selector, context ){//....　 
　　　//...... 
}; 

原来 jQuery.fn =jQuery.prototype.对prototype肯定不会陌生啦。 
jQuery便是一个封装得非常好的类，比如我们用语句　$("#btn1") 会生成一个 jQuery类的实例。 

jQuery.extend(object);　为jQuery类添加添加类方法，可以理解为添加静态方法。如： 
代码如下:
$.extend({ 
　　add:function(a,b){returna+b;} 
}); 

便为　jQuery　添加一个为add　的　“静态方法”，之后便可以在引入 jQuery　的地方，使用这个方法了， 
$.add(3,4); //return 7 

jQuery.fn.extend(object);对jQuery.prototype进得扩展，就是为jQuery类添加“成员函数”。jQuery类的实例可以使用这个“成员函数”。 
比如我们要开发一个插件，做一个特殊的编辑框，当它被点击时，便alert当前编辑框里的内容。可以这么做： 

jQuery代码 
代码如下:
$.fn.extend({ 

alertWhileClick:function(){ 

$(this).click(function(){ 

alert($(this).val()); 
}); 
} 
}); 
----------
Query为开发插件提拱了两个方法，分别是：
jQuery.fn.extend();
jQuery.extend();
虽然 javascript　没有明确的类的概念，但是用类来理解它，会更方便。
jQuery便是一个封装得非常好的类，比如我们用 语句　$("#btn1") 会生成一个 jQuery类的实例。
jQuery.extend(object);　为jQuery类添加类方法，可以理解为添加静态方法。如：
jQuery.extend({
min: function(a, b) { return a < b ? a : b; },
max: function(a, b) { return a > b ? a : b; }
});
jQuery.min(2,3); //  2 
jQuery.max(4,5); //  5

ObjectjQuery.extend( target, object1, [objectN])用一个或多个其他对象来扩展一个对象，返回被扩展的对象
var settings = { validate: false, limit: 5, name: "foo" }; 
var options = { validate: true, name: "bar" }; 
jQuery.extend(settings, options);
结果：settings == { validate: true, limit: 5, name: "bar" }

jQuery.fn.extend(object); 对jQuery.prototype进得扩展，就是为jQuery类添加“成员函数”。jQuery类的实例可以使用这个“成员函数”。
比如我们要开发一个插件，做一个特殊的编辑框，当它被点击时，便alert 当前编辑框里的内容。可以这么做：
$.fn.extend({          
     alertWhileClick:function() {            
           $(this).click(function(){                 
                  alert($(this).val());           
            });           
      }       
});       
$("#input1").alertWhileClick(); // 页面上为：    
$("#input1")　为一个jQuery实例，当它调用成员方法 alertWhileClick后，便实现了扩展，每次被点击时它会先弹出目前编辑里的内容。

</2014-8-21>
<2014-8-22>
一、异步加载
/** 选择学段时触发 */
$("#periodId").change(function() {
	asyncLoadSubject();
});

/** 异步加载学科 */
function asyncLoadSubject() {
	var periodId = $("#periodId").val();
	if (periodId == '') {
		$("#subjectId").empty();
		$("#editionId").empty();
		return;
	}
	var requestParam = {
		periodId: periodId
	};
	$.post("<%=WebApp.PATH%>/getRelatedSubjects.do", requestParam, function(data) {
		if (data.success && data.subjectList) {
			var subjectList = data.subjectList;
			var options = "<option value=''>--请选择--</option>";
			for (var i = 0; i < subjectList.length; i++) {
				options += "<option value='" + subjectList[i].subjectId + "'>" + subjectList[i].subjectName + "</option>";
			}
			$("#subjectId").html(options);
			$("#editionId").empty();
			$("#textbookId").empty();
		}
	}, "json");
}

二、Bootstrap（http://v3.bootcss.com/getting-started/）
Bootstrap是Twitter推出的一个开源的用于前端开发的工具包。它由Twitter的设计师Mark Otto和Jacob Thornton合作开发，是一个CSS/HTML框架。Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。



</2014-8-22>

<2014-8-25>
一、Sonatype Nexus
Maven仓库管理器

二、Linux命令
使用env命令显示所有的环境变量
使用set命令显示所有本地定义的Shell变量
使用unset命令来清除环境变量

set可以设置某个环境变量的值。清除环境变量的值用unset命令。如果未指定值，则该变量值将被设为NULL。示例如下：

　　$ export TEST="Test..." #增加一个环境变量TEST

　　$ env|grep TEST #此命令有输入，证明环境变量TEST已经存在了

　　TEST=Test...

　　$ unset $TEST #删除环境变量TEST

　　$ env|grep TEST #此命令没有输出，证明环境变量TEST已经存在了

使用readonly命令设置只读变量

　　如果使用了readonly命令的话，变量就不可以被修改或清除了。示例如下：

　　$ export TEST="Test..." #增加一个环境变量TEST

　　$ readonly TEST #将环境变量TEST设为只读

　　$ unset TEST #会发现此变量不能被删除

    $ TEST="New" #会发现此也变量不能被修改
环境变量的设置位于/etc/profile文件

　　如果需要增加新的环境变量可以添加下属行

　　export path=$path:/path1:/path2:/pahtN
按变量的生存周期来划分，Linux变量可分为两类：

　　1.1 永久的：需要修改配置文件，变量永久生效。

　　1.2 临时的：使用export命令声明即可，变量在关闭shell时失效。

　　2.设置变量的三种方法

　　2.1 在/etc/profile文件中添加变量【对所有用户生效(永久的)】

　　用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。

　　例如：编辑/etc/profile文件，添加CLASSPATH变量

　　# vi /etc/profile

　　export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib

　　注：修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。
2.2 在用户目录下的.bash_profile文件中增加变量【对单一用户生效(永久的)】

　　用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。

　　例如：编辑guok用户目录(/home/guok)下的.bash_profile

　　$ vi /home/guok/.bash.profile

　　添加如下内容：

　　export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib

　　注：修改文件后要想马上生效还要运行$ source /home/guok/.bash_profile不然只能在下次重进此用户时生效。
2.3 直接运行export命令定义变量【只对当前shell(BASH)有效(临时的)】

　　在shell的命令行下直接使用[export 变量名=变量值] 定义变量，该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。
PATH 决定了shell将到哪些目录中寻找命令或程序

　　HOME 当前用户主目录

　　HISTSIZE　历史记录数

　　LOGNAME 当前用户的登录名

　　HOSTNAME　指主机的名称

　　SHELL 　　当前用户Shell类型

　　LANGUGE 　语言相关的环境变量，多语言可以修改此环境变量

　　MAIL　　　当前用户的邮件存放目录

　　PS1　　　基本提示符，对于root用户是#，对于普通用户是$

三、sonatype nexus 搭建maven服务器 
1.下载nexus，下载oss版本

2.更改下载的nexus-xxx.war为nexus.war

3.拷贝到tomcat的webapp目录下

4.运行tomcat，进入nexus起始页

5.用admin/admin123登录

6. 点击Administration菜单下面的Repositories，将这三个仓库Apache Snapshots，Codehaus Snapshots，Maven Central的Download Remote Indexes修改为true。然后在这三个仓库上分别右键，选择Repair-index，这样Nexus就会去下载远程的索引文件。

7.修改maven对应本地库的setting.xml，添加如下内容


[html] view plaincopyprint?
01.  <profile>  
02.    <id>nexus</id>  
03.    <repositories>  
04.      <repository>  
05.        <id>nexus</id>  
06.        <name>Nexus</name>  
07.        <url>http://127.0.0.1:8080/nexus/content/groups/public/</url>  
08.        <releases>  
09.          <enabled>true</enabled>  
10.        </releases>  
11.        <snapshots>  
12.          <enabled>false</enabled>  
13.        </snapshots>  
14.      </repository>  
15.    </repositories>  
16.    <pluginRepositories>  
17.      <pluginRepository>  
18.        <id>nexus</id>  
19.        <name>Nexus</name>  
20.        <url>http://127.0.0.1:8080/nexus/content/groups/public/</url>  
21.        <releases>  
22.          <enabled>true</enabled>  
23.        </releases>  
24.        <snapshots>  
25.          <enabled>false</enabled>  
26.        </snapshots>  
27.      </pluginRepository>  
28.    </pluginRepositories>  
29.  </profile>  
30.</profiles>  
31.<activeProfiles>  
32.  <activeProfile>nexus</activeProfile>  
33.</activeProfiles>  

</2014-8-25>

<2014-8-26>
一、js用法
$.ajax({
		url : "uploadResource.do",
		type : "post",
		sync : true,
		data : $("#form0").serialize(),
		dataType : "json",
		success : function(data) {
			if (data.success) {
				alert(data.message);
				location.href = "myNetdisk.htm?parentId="
						+ data.parentId;
			}
		}
	});
----------
$.ajax({
		url : "queryResType.do",
		type : "post",
		sync : true,
		data : {
			"resTypePid" : resType
		},
		dataType : "json",
		success : function(data) {
			if (data.success) {
				$.each(data.data, function(i, n) {
					option = option
							+ "<option value=\""+n.resTypeId+"\">"
							+ n.resTypeName + "</option>";

				})
				$("#contentTypeChild").html(option);
			}
		}
	});
	i 是当前循环到第几次.n 是值相当于var k =[0,1,2]
	for(var i=0;i<k.length;i++){     
	// 这里的 i 就是 function(i,n)中的i    
	// k[i] 就是 n}
------
success:function(data){}
回调函数，此处的data为执行了url请求之后return回来的值，例如：
public Object uploadResource(){
	Map map = MapUtils.newHashMap();
	map.put(SUCCESS, new Boolean(true));
	map.put(MESSAGE, ADD_SUCCESS);
	map.put("parentId", queryBean.getParentId());
return map;
}

二、Ajax请求中的async:false/true的作用 .
test.html

<a href="javascript:void(0)" onmouseover="testAsync()">

asy.js

function testAsync(){
    var temp;
    $.ajax({
        async: false,
        type : "GET",
        url : 'tet.php',
        complete: function(msg){
            alert('complete');
        },
        success : function(data) {
            alert('success');
            temp=data;
        }
    });
    alert(temp+'   end');
}

tet.php

<?php

    echo "here is html code";
    sleep(5);

?>

async: false,（默认是true）;
如上：false为同步，这个 testAsync()方法中的Ajax请求将整个浏览器锁死，
只有tet.php执行结束后，才可以执行其它操作。
function testAsync(){
    var temp;
    $.ajax({
        async: false,
        type : "GET",
        url : 'tet.php',
        complete: function(msg){
            alert('complete');
        },
        success : function(data) {
            alert('success');
            temp=data;
        }
    });
    alert(temp+'   end');
}

tet.php

<?php

    echo "here is html code";
    sleep(5);

?>

当async: true 时，ajax请求是异步的。但是其中有个问题：testAsync()中的ajax请求和其后面的操作是异步执行的，那么当tet.php还未执行完，就可能已经执行了 ajax请求后面的操作，
如： alert(temp+'   end');
然而，temp这个数据是在ajax请求success后才赋值的，结果，输出时会为空。

三、JavaScript eval() 函数
eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。
<script type="text/javascript">

eval("x=10;y=20;document.write(x*y)")

document.write(eval("2+2"))

var x=10
document.write(eval(x+17))

</script>
输出：
200
4
27

eval("2+3")	// 返回 5
var myeval = eval;	// 可能会抛出 EvalError 异常
myeval("2+3");	// 可能会抛出 EvalError 异常
可以使用下面这段代码来检测 eval() 的参数是否合法：

try  {
     alert("Result:" + eval(prompt("Enter an expression:","")));
     }

catch(exception) {
     alert(exception);
     }

四、jQuery用法
var kws = $('#keyword').val().split('，').join(',').replace(/\t+/g,'').split(',');
var kws_len = 0;
var kwsarr = [];
for(var i=0; i<kws.length;i++){
	if ( kws[i]!=='' ) {
		kws_len ++;
		kwsarr.push(kws[i]);
	}            
}
$('#keyWord').val(kwsarr.join(','));
if (kws_len>5){
	alert('资源标签最多只能填5个i');
	$('#keyWord').focus();
	return false;
}
------
js中join函数的使用方法:
数组对象本身提供了许多方法用于对象本身的操作，join是其中一个方法。
它的作用是将数组转换为字符串，其作用和toString()相同。

比如我们有个字符串"a","b","c"我们要输出为a,b,c这样的格式，那么我们可以这样：
var a = ["a","b","c"];
document.write(a);
若使用join，那必须得这样：
var a = ["a","b","c"].join(",");
document.write(a);
如果你说你要直接输出abc，而不输出a,b,c，那使用join再合适不过。
var a = ["a","b","c"].join("");
document.write(a);


五、
1、onchange事件与onpropertychange事件的区别： 
onchange事件在内容改变（两次内容有可能还是相等的）且失去焦点时触发；onpropertychange事件却是实时触发，即每增加或删除一个字符就会触发，通过js改变也会触发该事件，但是该事件IE专有。 
2、oninput事件与onpropertychange事件的区别： 
oninput事件是IE之外的大多数浏览器支持的事件，在value改变时触发，实时的，即每增加或删除一个字符就会触发，然而通过js改变 value时，却不会触发；onpropertychange事件是任何属性改变都会触发的，而oninput却只在value改变时触发，oninput要通过addEventListener()来注册，onpropertychange注册方式跟一般事件一样。（此处都是指在js中动态绑定事件，以实现内容与行为分离） 
3、oninput与onpropertychange失效的情况： 
（1）oninput事件：a). 当脚本中改变value时，不会触发；b). 从浏览器的自动下拉提示中选取时，不会触发。 
（2）onpropertychange事件：当input设置为disable=true后，onpropertychange不会触发。 

六、innerHTML,innerTEXT
 JS初学者易混淆的问题；innerHTML，innerText，value（他们和JQ的区别：JS→value，JQ→value()）
1、getElementById("a").innerHTML="";
     getElementById("a").innerText="";  这两个的区别直接上图，不解释了。
innerHTML，是在块中加html代码；innerText 在块中加文字。 (注意大小写)!!!!!!

2、getElementById("a").innerHTML="";
     getElementById("a").value="";
有value属性的标签才能使用getElementById().value------这个被我证实是错误的！
.value是一个介于innerHTML和innerText的效果
既不会显示代码，还可以显示文本

innerHTML
<!DOCTYPE html><html><body><h1>My First Web Page</h1><p id="demo">My First Paragraph.</p><script>document.getElementById("demo").innerHTML="<h1>My First JavaScript</h1>";</script></body></html>输出结果:
My First Web Page 
My First JavascriptinnerText

<!DOCTYPE html><html><body><h1>My First Web Page</h1><p id="demo">My First Paragraph.</p><script>document.getElementById("demo").innerText="<h1>My First JavaScript</h1>";</script></body></html>输出结果：
My First Web Page
<h1>My First Javascript</h1>value

<!DOCTYPE html><html><body><h1>My First Web Page</h1><p id="demo">My First Paragraph.</p><script>document.getElementById("demo").value="<h1>My First JavaScript</h1>";</script></body></html>输出结果：
My First Web Page
My First Paragraph.

七、
<tr>
	<td colspan="2">
		<span class="red">*</span>资源信息：<input type="text" style="width:600px;" class="inp w630 black" name="title" id="title1" value="" placeholder=""/><span id="nameLimit">0</span>/30</td>
	</td>
</tr>
<script type="text/javascript" src="common/js/jquery.inputlimiter.1.3.1.min.js"></script>
//资源标题长度截取
		$('#title').inputlimiter({
			limit: 30,
			boxId: 'nameLimit',
			remText: '%n',//匹配显示
			limitText: '',//匹配文字
			boxAttach: false,
			remTextHideOnBlur:false
		}); 
</2014-8-26>

<2014-8-27>
一、面包屑导航
作用
1、让用户了解当前所处位置，以及当前页面在整个网站中的位置。
2、体现了网站的架构层级，能够帮助用户快速学习和了解网站内容和组织方式，从而形成很好的位置感。
3、提供返回各个层级的快速入口，方便用户操作。
4、Google已经将面包屑导航整合到搜索结果里面，因此优化面包屑导航每个层级的名称，多使用关键字，都可以实现SEO优化。面包屑路径，对于提高用户体验来说，是很有帮助的。
5、方便用户，面包屑主要用于为用户提供导航一个网站的次要方法，通过为一个大型多级网站的所有页面提供面包屑路径，用户可以更容易的定位到上一次目录，引导用户通行；
6、减少返回到上一级页面的点击或操作，不用使用浏览器的“返回”按钮或网站的主要导航来返回到上一级页面；
7、不用常常占用屏幕空间，因为它们通常是水平排列以及简单的样式，面包屑路径不会占用页面太多的空间。这样的好处是，从内容过载方面来说，他们几乎没有任何负面影响；
8、降低跳出率，面包屑路径会是一个诱惑首次访问者在进入一个页面后去浏览这个网站的非常好的方法。比如说，一个用户通过谷歌搜索到一个页面，然后看到一个面包屑路径，这将会诱使用户点击上一级页面去浏览感兴趣的相关主题。这样，从而，可以降低网站的总体跳出率。
9、有利于百度蜘蛛对网站的抓取，蜘蛛直接沿着那个链走就可以了，很方便。
10、面包屑有利于网站内链的建设，用面包屑大大增加了网站的内部连接，提高用户体验。

二、
<link href="common/css/public.css?" rel="stylesheet" type="text/css" />
script type="text/javascript" src="common/js/fun.js?" charset="utf-8"></script>
加？是为了清缓存

</2014-8-27>

<2014-8-28>
一、数据库查询
select * from t_room t where t.room =''或者 t.room = null
“=”：就表示存在，这样写不起作用，用is null

二、SpringMVC中使用Interceptor拦截器
SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor 来实现的。在SpringMVC 中定义一个Interceptor 非常简单，主要有两种方式，第一种方式是要定义的Interceptor类要实现了Spring 的HandlerInterceptor 接口，或者是这个类继承实现了HandlerInterceptor 接口的类，比如Spring 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter ；第二种方式是实现Spring的WebRequestInterceptor接口，或者是继承实现了WebRequestInterceptor的类。
---------
把定义的拦截器类加到SpringMVC的拦截体系中

         1.在SpringMVC的配置文件中加上支持MVC的schema
Xml代码  收藏代码
    xmlns:mvc="http://www.springframework.org/schema/mvc"  
    xsi:schemaLocation=" http://www.springframework.org/schema/mvc  
        http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"  
 
         下面是我的声明示例：
Xml代码  收藏代码
<beans xmlns="http://www.springframework.org/schema/beans"  
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"  
    xmlns:mvc="http://www.springframework.org/schema/mvc"  
    xsi:schemaLocation="http://www.springframework.org/schema/beans  
     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
     http://www.springframework.org/schema/context  
     http://www.springframework.org/schema/context/spring-context-3.0.xsd  
     http://www.springframework.org/schema/mvc  
     http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd">  
         这样在SpringMVC的配置文件中就可以使用mvc标签了，mvc标签中有一个mvc:interceptors是用于声明SpringMVC的拦截器的。
 
        （二）使用mvc:interceptors标签来声明需要加入到SpringMVC拦截器链中的拦截器
Xml代码  收藏代码
<mvc:interceptors>  
    <!-- 使用bean定义一个Interceptor，直接定义在mvc:interceptors根下面的Interceptor将拦截所有的请求 -->  
    <bean class="com.host.app.web.interceptor.AllInterceptor"/>  
    <mvc:interceptor>  
        <mvc:mapping path="/test/number.do"/>  
        <!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 -->  
        <bean class="com.host.app.web.interceptor.LoginInterceptor"/>  
    </mvc:interceptor>  
</mvc:interceptors>  
由上面的示例可以看出可以利用mvc:interceptors标签声明一系列的拦截器，然后它们就可以形成一个拦截器链，拦截器的执行顺序是按声明的先后顺序执行的，先声明的拦截器中的preHandle方法会先执行，然而它的postHandle方法和afterCompletion方法却会后执行。
在mvc:interceptors标签下声明interceptor主要有两种方式：
		（1）直接定义一个Interceptor实现类的bean对象。使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截。
		（2）使用mvc:interceptor标签进行声明。使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。


三、ztree
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ include file="/WEB-INF/views/common/import.jsp" %>
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta http-equiv="Pragrma" content="no-cache">
		<meta http-equiv="Expires" content="0">
		<%@ include file="/WEB-INF/views/common/cssjs.jsp" %>
		<link rel="stylesheet" href="<%=WebApp.PATH%>/cssjs/zTree/css/zTreeStyle/zTreeStyle.css" type="text/css">
		<script type="text/javascript" src="<%=WebApp.PATH%>/cssjs/zTree/js/jquery.ztree.core-3.5.js"></script>
		<script type="text/javascript">
			function showMenu(event, treeId, treeNode) {
				var url = treeNode.action;
				if (url == "") {
					return;
				}
				url = "<%=WebApp.PATH%>" + url;
				parent.showMain(url);
			}
			// zTree配置
			var setting = {
				data : {
					simpleData : {
						enable : true
					}
				},
				callback: {
					onClick: showMenu
				}
			};
			
			var zNodes = [
				{id:'1', pId:'0', name:'基础数据管理', action:'', icon:'<%=WebApp.PATH%>/images/icons/server_database.png'},
				{id:'101', pId:'1', name:'学段管理', action:'/period.htm', icon:'<%=WebApp.PATH%>/images/icons/anchor.png'},
				
				{id:'2', pId:'0', name:'资源管理', action:'', icon:'<%=WebApp.PATH%>/images/icons/database_refresh.png'},
				{id:'201', pId:'2', name:'机构资源管理', action:'/orgResource.htm', icon:'<%=WebApp.PATH%>/images/icons/database_table.png'},

				{id:'3', pId:'0', name:'产品管理', action:'', icon:'<%=WebApp.PATH%>/images/icons/television.png'},
				{id:'301', pId:'3', name:'创建产品', action:'/createProduct.htm', icon:'<%=WebApp.PATH%>/images/icons/bin.png'}
			];
			
			$(function() {
				$.fn.zTree.init($("#menuTree"), setting, zNodes);
			});
		</script>
	</head>
	<body style="margin:0px;padding:0px;">
		<ul id="menuTree" class="ztree"></ul>
	</body>
</html>

四、set,get方法用法
    public String getUsedCapacitySize() {
    	if(CommonFunction.isNotNull(usedCapacity)){
	    	java.text.DecimalFormat   df   =new   java.text.DecimalFormat("#.00");  
	    	float size = usedCapacity.intValue() / (float)1024;
	    	if(size < 1024){
	    	  return df.format(size)+"KB";
	    	}else if(size >= 1024 && size < 1024*1024){
	    	  return df.format(size/1024)+"MB";
	    	}else if(size >= 1024*1024){
	    	  return df.format(size/(1024*1024))+"GB";
	    	}
    	}
    	return null;
	}

	public void setUsedCapacitySize(String usedCapacitySize) {
		this.usedCapacitySize = usedCapacitySize;
	}

五、字符长度控制
var self = $("div[limit]");
self.each(function(){   
	var objString = $(this).text();   
	var objLength = $(this).text().length;  
	var num = $(this).attr("limit");   
	if(objLength > num){   
		$(this).attr("title",objString);   
		objString = $(this).text(objString.substring(0,num) + "...");   
	}   
})

jQuery.fn.limit = function() {
			var self = $("div[limit]");
			self.each(function() {
				var objString = $(this).text();
				var objLength = $(this).text().length;
				var num = $(this).attr("limit");
				if (objLength > num) {
					$(this).attr("title", objString);
					objString = $(this).text(
							objString.substring(0, num) + "...");
				}
			})
		}

1.jQuery.fn.limit=function(){}，用以为jQuery扩展一个实例函数，jQuery对象可以调用此函数。
2.var self = $("div[limit]"),用以获去具有limit属性的div对象集合。
3.self.each(function(){ }，可以让获取的让div对象集合中的每一个对象遍历执行一次指定的函数。
4.var objString = $(this).text()，获取div元素中的文本内容，这里的this是指当each()函数进行遍历时当前div。
5.var objLength = $(this).text().length，获取当前div中文本内容的长度。
6.var num = $(this).attr("limit")，获取div中limit属性值，在这里用作了指定的字符长度。
7.if(objLength > num){},div中文本内容长度大于指定长度这执行指定的代码。
8.$(this).attr("title",objString)，将div的title属性值设置为div中的内容。
9.objString = $(this).text(objString.substring(0,num) + "...")，截取指定长度字符串，超出的用省略号代替。
</2014-8-28>

<2014-09-01>


</2014-09-01>

<2014-09-02>
一、Filter类
Filter可认为是Servlet的一种“变种”，它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。它与Servlet的区别在于：它不能直接向用户生成响应。完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。

Filter有如下几个用处。

在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest。

根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。

在HttpServletResponse到达客户端之前，拦截HttpServletResponse。

根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。

Filter有如下几个种类。

用户授权的Filter：Filter负责检查用户请求，根据请求过滤用户非法请求。

日志Filter：详细记录某些特殊的用户请求。

负责解码的Filter：包括对非标准编码的请求解码。

能改变XML内容的XSLT Filter等。

Filter可负责拦截多个请求或响应；一个请求或响应也可被多个请求拦截。

创建一个Filter只需两个步骤：

建Filter处理类；

web.xml文件中配置Filter。

2.12.1 创建Filter类

创建Filter必须实现javax.servlet.Filter接口，在该接口中定义了3个方法。

void init(FilterConfig config)：用于完成Filter的初始化。

void destroy()：用于Filter销毁前，完成某些资源的回收。

void doFilter(ServletRequest request, ServletResponse response,FilterChain chain)：实现过滤功能，该方法就是对每个请求及响应增加的额外处理。


二、web工程之间的接口调用
String url = SysConfig.getProperty("sme.api.url");
JSONObject objJson = new JSONObject();
List<String> list = new ArrayList<String>();
list.add(contentId);
objJson.put("resourcelist", list);
String ret = HttpClientUtils.post(url+"resourcedown", objJson.toString(), "utf-8", 5000);
-----
public static String post(String url, String paramvalue, String charsetName, int timeoutms) {
	String resStr = "";
	HttpClient httpclient = null;
	try {
	    httpclient = new DefaultHttpClient();
	    httpclient.getParams().setIntParameter("http.socket.timeout", timeoutms);
	    HttpPost httppost = new HttpPost(url);

	    StringEntity entity = new StringEntity(paramvalue, charsetName);
	    entity.setChunked(true);

	    httppost.setEntity(entity);
	    HttpResponse response = httpclient.execute(httppost);
	    HttpEntity resEntity = response.getEntity();

	    if (resEntity != null) {
		InputStream is = resEntity.getContent();
		resStr = convertStreamToString(is, charsetName);
	    }
	} catch (ClientProtocolException e) {
	    logger.info(e.getMessage());
	} catch (IOException e) {
	    logger.info(e.getMessage());
	} finally {
	    // HttpClient的实例不再需要时，降低连接，管理器关闭，以确保立即释放所有系统资源
	    if (httpclient != null)
		httpclient.getConnectionManager().shutdown();
	}
	logger.debug("interface return result: " + resStr);
	return resStr;
    }
-----
public static String convertStreamToString(InputStream is, String charsetName) {
	StringBuilder sb = new StringBuilder();
	try {
	    BufferedReader reader = new BufferedReader(new InputStreamReader(is, charsetName));
	    String line = null;
	    while ((line = reader.readLine()) != null) {
		sb.append(line + "\n");
	    }
	} catch (IOException e) {
	    logger.info(e.getMessage());
	} finally {
	    try {
		is.close();
	    } catch (IOException e) {
		logger.info(e.getMessage());
	    }
	}
	return sb.toString();
    }
-----

</2014-09-01>

<2014-09-03>
一、VPN

二、ckplayer



</2014-09-03>

<2014-09-04>
一、noscript
noscript 元素用来定义在脚本未被执行时的替代内容（文本）。[1] 
此标签可被用于可识别 <script> 标签但无法支持其中的脚本的浏览器。
此段代码意思为如果浏览器不支持script的代码，则会显示嵌入的那个页面的内容

<noscript> 标签用来记述在不支持 <script> 标签的浏览器上显示的信息。支持脚本语言的浏览器会自动忽略 <noscript>～</noscript> 里的文字。不支持脚本语言的浏览器会显示 <noscript>～</noscript> 里的文字。

三、事务管理
多个关联表保存时，不要写在action中，最好写在service中，同时service的方法格式：
<!-- tx advice -->
	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<tx:method name="add*" propagation="REQUIRED" />
			<tx:method name="insert*" propagation="REQUIRED" />
			<tx:method name="del*" propagation="REQUIRED" />
			<tx:method name="remove*" propagation="REQUIRED" />
			<tx:method name="update*" propagation="REQUIRED" />
			<tx:method name="mod*" propagation="REQUIRED" />
			<tx:method name="*" read-only="true" />
		</tx:attributes>
	</tx:advice>

	<!-- aop config -->
	<aop:config>
		<aop:advisor advice-ref="txAdvice"
			pointcut="execution(* com.whty.cms.web..*.*Service.*(..))" />
	</aop:config>
比如：一个一个保存时在报错的情况下，会产生多余的数据。
这种情况可以使用service事务管理来解决。

四、编目
编目：按照一定的标准和规则，对某范围内文献信息资源每种实体（Item）的外部特征和内容特征进行分析、选择、描述，并予以记录成为款目，继而将款目按一定顺序组织成为目录（Catalogue）或书目（Bibliography）的过程。

五、JAVA读取隐藏文件

六、列出文件大小
du -sh *

Linux为我们提供了两个用于文件copy的命令，一个是cp，一个是scp，但是他们略有不同，cp 主要是用于在同一台电脑上，在不同的目录之间来回copy文件 scp 主要是在不同的Linux系统之间来回copy文件


命令：scp
不同的Linux之间copy文件常用有3种方法：

第一种就是ftp，也就是其中一台Linux安装ftp Server，这样可以另外一台使用ftp的client程序来进行文件的copy。
第二种方法就是采用samba服务，类似Windows文件copy 的方式来操作，比较简洁方便。
第三种就是利用scp命令来进行文件复制。
    scp是有Security的文件copy，基于ssh登录。操作起来比较方便，比如要把当前一个文件copy到远程另外一台主机上，可以如下命令。
scp /home/daisy/full.tar.gz root@172.19.2.75:/home/root
然后会提示你输入另外那台172.19.2.75主机的root用户的登录密码，接着就开始copy了。
    如果想反过来操作，把文件从远程主机copy到当前系统，也很简单。
scp root@/full.tar.gz 172.19.2.75:/home/root/full.tar.gz home/daisy/full.tar.gz
linux 的 scp 命令 可以 在 linux 之间复制 文件 和 目录； 

注意两点：
1.如果远程服务器防火墙有特殊限制，scp便要走特殊端口，具体用什么端口视情况而定，命令格式如下：
#scp -p 4588 remote@www.abc.com:/usr/local/sin.sh /home/administrator
2.使用scp要注意所使用的用户是否具有可读取远程服务器相应文件的权限。


scp就是secure copy，是用来进行远程文件拷贝的。数据传输使用 ssh，并且和ssh 使用相同的认证方式，提供相同的安全保证 。 与rcp 不同的是，scp 在需要进行验证时会要求你输入密码或口令。

</2014-09-04>

<2014-09-11>
一、solr查询参数
名称
 描述
 
q
 查询字符串，必须的。
 
fq
 filter query。使用Filter Query可以充分利用Filter Query Cache，提高检索性能。作用：在q查询符合结果中同时是fq查询符合的，例如：q=mm&fq=date_time:[20081001 TO 20091031]，找关键字mm，并且date_time是20081001到20091031之间的。
 
fl
 field list。指定返回结果字段。以空格“ ”或逗号“,”分隔。
 
start
 用于分页定义结果起始记录数，默认为0。
 
rows
 用于分页定义结果每页返回记录数，默认为10。
 
sort
 排序，格式:sort=<field name>+<desc|asc>[,<field name>+<desc|asc>]… 。示例：（inStock desc, price asc）表示先 “inStock” 降序, 再 “price” 升序，默认是相关性降序。
 
df
 默认的查询字段，一般默认指定。
 
q.op
 覆盖schema.xml的defaultOperator（有空格时用"AND"还是用"OR"操作逻辑），一般默认指定。必须大写
 
wt
 writer type。指定查询输出结构格式，默认为“xml”。在solrconfig.xml中定义了查询输出格式：xml、json、python、ruby、php、phps、custom。
 
qt
 query type，指定查询使用的Query Handler，默认为“standard”。
 
explainOther
 设置当debugQuery=true时，显示其他的查询说明。
 
defType
 设置查询解析器名称。
 
timeAllowed
 设置查询超时时间。
 
omitHeader
 设置是否忽略查询结果返回头信息，默认为“false”。
 
indent
 返回的结果是否缩进，默认关闭，用 indent=true|on 开启，一般调试json,php,phps,ruby输出才有必要用这个参数。
 
version
 查询语法的版本，建议不使用它，由服务器指定默认值。
 
debugQuery
 设置返回结果是否显示Debug信息。
 
二、Hadoop
一个分布式系统基础架构，由Apache基金会所开发。
用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。
[1] Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。
Hadoop的框架最核心的设计就是：HDFS和MapReduce.HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算。

对外部客户机而言，HDFS就像一个传统的分级文件系统。可以创建、删除、移动或重命名文件，等等。但是 HDFS 的架构是基于一组特定的节点构建的（参见图 1），这是由它自身的特点决定的。这些节点包括 NameNode（仅一个），它在 HDFS 内部提供元数据服务；DataNode，它为 HDFS 提供存储块。由于仅存在一个 NameNode，因此这是 HDFS 的一个缺点（单点失败）。
NameNode 是一个通常在 HDFS 实例中的单独机器上运行的软件。它负责管理文件系统名称空间和控制外部客户机的访问。
DataNode 也是一个通常在 HDFS实例中的单独机器上运行的软件。Hadoop 集群包含一个 NameNode 和大量 DataNode。DataNode 通常以机架的形式组织，机架通过一个交换机将所有系统连接起来。Hadoop 的一个假设是：机架内部节点之间的传输速度快于机架间节点的传输速度。
DataNode 响应来自 HDFS 客户机的读写请求。它们还响应来自 NameNode 的创建、删除和复制块的命令。NameNode 依赖来自每个 DataNode 的定期心跳（heartbeat）消息。每条消息都包含一个块报告，NameNode 可以根据这个报告验证块映射和其他文件系统元数据。如果 DataNode 不能发送心跳消息，NameNode 将采取修复措施，重新复制在该节点上丢失的块。

三、JIRA


四、SVN服务器搭建(http://www.cnblogs.com/xiaobaihome/archive/2012/03/20/2408089.html)


</2014-09-11>

<2014-09-12>
一、
点击上传后判断是否登录，如果没有登录则跳转到登录页面


二、Velocity
Velocity是一个基于java的模板引擎（template engine）。它允许任何人仅仅简单的使用模板语言（template language）来引用由java代码定义的对象。 当Velocity应用于web开发时，界面设计人员可以和java程序开发人员同步开发一个遵循MVC架构的web站点，也就是说，页面设计人员可以只关注页面的显示效果，而由java程序开发人员关注业务逻辑编码。Velocity将java代码从web页面中分离出来，这样为web站点的长期维护提供了便利，同时也为我们在JSP和PHP之外又提供了一种可选的方案。 Velocity的能力远不止web站点开发这个领域，例如，它可以从模板（template）产生SQL和PostScript、XML，它也可以被当作一个独立工具来产生源代码和报告，或者作为其他系统的集成组件使用。Velocity也可以为Turbine web开发架构提供模板服务（template service）。Velocity+Turbine提供一个模板服务的方式允许一个web应用以一个真正的MVC模型进行开发。 
【VeloEclipse ：Velocity在Eclipse平台下的一个辅助开发插件】

三、Spring中Quartz调度器的使用
Quartz的特点

* 按作业类的继承方式来分，主要有以下两种：

1.作业类继承org.springframework.scheduling.quartz.QuartzJobBean类的方式

2.作业类不继承org.springframework.scheduling.quartz.QuartzJobBean类的方式

注：个人比较推崇第二种，因为这种方式下的作业类仍然是POJO。

* 按任务调度的触发时机来分，主要有以下两种：

1.每隔指定时间则触发一次，对应的调度器为org.springframework.scheduling.quartz.SimpleTriggerBean

2.每到指定时间则触发一次，对应的调度器为org.springframework.scheduling.quartz.CronTriggerBean

注：这两种触发方式均可以跟两种作业继承方式相互组合来使用。

下面简单演示一下在Spring对Quartz的用法。

二、作业类继承org.springframework.scheduling.quartz.QuartzJobBean类，每到指定时间则触发一次

1.编写作业类

package bean.jobDetailBean;

import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.springframework.scheduling.quartz.QuartzJobBean;

public class Job1 extends QuartzJobBean {

private int timeout;
private static int i = 0;

//调度工厂实例化后，经过timeout时间开始执行调度
public void setTimeout(int timeout) {
this.timeout = timeout;
}

/**
* 要调度的具体任务
*/
@Override
protected void executeInternal(JobExecutionContext context)
throws JobExecutionException {

System.out.println("继承QuartzJobBean的方式-调度" + ++i + "进行中...");
}
}

2.配置作业类

<!-- 作业使用继承QuartzJobBean的方式  -->
<bean name="job1" class="org.springframework.scheduling.quartz.JobDetailBean">
<property name="jobClass" value="bean.jobDetailBean.Job1" />
<property name="jobDataAsMap">
<map>
<entry key="timeout" value="0" />
</map>
</property>
</bean>

3.配置作业调度的触发方式

<!-- 对应于作业继QuartzJobBean类的方式  -->
<bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean">
<property name="jobDetail" ref="job1" />

<!-- 
"cronExpression"的配置说明

字段   允许值   允许的特殊字符
秒    0-59    , - * /
分    0-59    , - * /
小时    0-23    , - * /
日期    1-31    , - * ? / L W C
月份    1-12 或者 JAN-DEC    , - * /
星期    1-7 或者 SUN-SAT    , - * ? / L C #
年（可选）    留空, 1970-2099    , - * / 

- 区间  
* 通配符  
? 你不想设置那个字段
-->

<!-- 每分钟的第0,10,20,30,40,50秒调度一次 -->
<property name="cronExpression" value="0,10,20,30,40,50 * * * * ?" />
</bean>

4.配置调度工厂

<bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
<property name="triggers">
<list>
<ref bean="cronTrigger" />
</list>
</property>
</bean>

5.开启调度

package test;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class ScheduleTest {

public static void main(String[] args){

BeanFactory factory = new ClassPathXmlApplicationContext("applicationContext*.xml");
}
}

6.调度执行的结果

继承QuartzJobBean的方式-调度1进行中...
继承QuartzJobBean的方式-调度2进行中...
继承QuartzJobBean的方式-调度3进行中...
继承QuartzJobBean的方式-调度4进行中...
继承QuartzJobBean的方式-调度5进行中...
继承QuartzJobBean的方式-调度6进行中...
继承QuartzJobBean的方式-调度7进行中...
继承QuartzJobBean的方式-调度8进行中...
继承QuartzJobBean的方式-调度9进行中...

三、作业类不继承org.springframework.scheduling.quartz.QuartzJobBean类，每隔指定时间则触发一次

1.编写作业类

package bean.jobDetailBean;

public class Job2 {

private static int i = 0;

public void doJob2() {

System.out.println("不继承QuartzJobBean方式-调度" + ++i + "进行中...");
}
}

2.配置作业类

<bean id="job2"
class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
<property name="targetObject">
<bean class="bean.jobDetailBean.Job2" />
</property>
<property name="targetMethod" value="doJob2" />
<property name="concurrent" value="false" /><!-- 作业不并发调度 -->
</bean>

3.配置作业调度的触发方式

<bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerBean">
<property name="jobDetail" ref="job2" />
<property name="startDelay" value="0" /><!-- 调度工厂实例化后，经过0秒开始执行调度 -->
<property name="repeatInterval" value="2000" /><!-- 每2秒调度一次 -->
</bean>

4.配置调度工厂

<bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
<property name="triggers">
<list>
<ref bean="simpleTrigger" />
</list>
</property>
</bean>

5.开启调度

package test;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class ScheduleTest {

public static void main(String[] args){

BeanFactory factory = new ClassPathXmlApplicationContext("applicationContext*.xml");
}
}

6.调度执行的结果

不继承QuartzJobBean方式-调度1进行中...
不继承QuartzJobBean方式-调度2进行中...
不继承QuartzJobBean方式-调度3进行中...
不继承QuartzJobBean方式-调度4进行中...
不继承QuartzJobBean方式-调度5进行中...
不继承QuartzJobBean方式-调度6进行中...
不继承QuartzJobBean方式-调度7进行中...
不继承QuartzJobBean方式-调度8进行中...
不继承QuartzJobBean方式-调度9进行中...
不继承QuartzJobBean方式-调度10进行中...

</2014-09-12>


